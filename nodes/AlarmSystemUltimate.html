<script type="text/javascript">
  RED.nodes.registerType("AlarmSystemUltimate", {
    category: "Alarm Ultimate",
    color: "#A8DADC",
    defaults: {
      name: { value: "" },
      controlTopic: { value: "alarm" },
      payloadPropName: { value: "payload", required: false },
      persistState: { value: true },
      syncTargets: { value: "" },
      requireCodeForArm: { value: false },
      requireCodeForDisarm: { value: true },
      armCode: { value: "" },
      duressCode: { value: "" },
      blockArmOnViolations: { value: true },
      exitDelaySeconds: { value: 30, validate: RED.validators.number() },
      entryDelaySeconds: { value: 30, validate: RED.validators.number() },
      emitOpenZonesDuringArming: { value: false },
      openZonesArmingIntervalSeconds: {
        value: 1,
        validate: RED.validators.number(),
      },
      openZonesRequestTopic: { value: "alarm/listOpenZones" },
	      openZonesRequestIntervalSeconds: {
	        value: 0,
	        validate: RED.validators.number(),
	      },
	      emitOpenZonesCycle: { value: false },
	      openZonesCycleIntervalSeconds: {
	        value: 5,
	        validate: RED.validators.number(),
	      },
      sirenDurationSeconds: { value: 180, validate: RED.validators.number() },
      sirenLatchUntilDisarm: { value: false },
      sirenTopic: { value: "siren" },
      sirenOnPayload: { value: true },
      sirenOnPayloadType: { value: "bool" },
      sirenOffPayload: { value: false },
      sirenOffPayloadType: { value: "bool" },
      emitRestoreEvents: { value: false },
      maxLogEntries: { value: 50, validate: RED.validators.number() },
      zones: { value: "" },
    },
    inputs: 1,
    outputs: 10,
    outputLabels: [
      "All messages",
      "Siren",
      "Alarm triggered",
      "Arm/Disarm updates",
      "Zone activity",
      "Errors/Denied",
      "Any zone open",
      "Open zones (arming)",
      "Open zones (on request)",
      "Open zones (cycle)",
    ],
    icon: "alarm-ultimate.svg",
    label: function () {
      return this.name || "Alarm System (BETA)";
    },
    paletteLabel: function () {
      return "Alarm System (BETA)";
    },
	    oneditprepare: function () {
	      const nodeId = this.id;
      const initialNodeName = String(this.name || "");
	      const origin = window.location.origin;
	      const openerOrigin = origin;
	      const tabs = RED.tabs.create({
	        id: "node-input-au-tabs",
	        onchange: function (tab) {
	          $("#node-input-au-tabs-content").children(".au-tab").hide();
	          $("#" + tab.id).show();
	        },
	      });
	      tabs.addTab({ id: "node-input-au-tab-zones", label: "Zones" });
	      tabs.addTab({ id: "node-input-au-tab-general", label: "General" });
	      tabs.addTab({ id: "node-input-au-tab-security", label: "Security" });
	      tabs.addTab({ id: "node-input-au-tab-siren", label: "Siren" });
	      tabs.addTab({ id: "node-input-au-tab-open-zones", label: "Open zones" });
	      tabs.addTab({ id: "node-input-au-tab-advanced", label: "Advanced" });
	      tabs.activateTab("node-input-au-tab-general");
	      const bc =
	        typeof BroadcastChannel === "function"
	          ? new BroadcastChannel("alarm-ultimate-zones")
	          : null;
      const payloadField = $("#node-input-payloadPropName");
      if (payloadField.val() === "") payloadField.val("payload");
      payloadField.typedInput({ default: "msg", types: ["msg"] });

      $("#node-input-sirenOnPayload").typedInput({
        default: this.sirenOnPayloadType || "bool",
        types: ["str", "num", "bool", "json", "date"],
      });
      $("#node-input-sirenOnPayload").typedInput(
        "type",
        this.sirenOnPayloadType || "bool",
      );

      $("#node-input-sirenOffPayload").typedInput({
        default: this.sirenOffPayloadType || "bool",
        types: ["str", "num", "bool", "json", "date"],
      });
      $("#node-input-sirenOffPayload").typedInput(
        "type",
        this.sirenOffPayloadType || "bool",
      );

      const zonesField = $("#node-input-zones");
      const zonesSummary = $("#node-input-zones-summary");
      const zonesExportBtn = $("#node-input-zones-export");
      const zonesImportBtn = $("#node-input-zones-import");
      const zonesImportFile = $("#node-input-zones-import-file");
      const syncTargetsField = $("#node-input-syncTargets");
      const syncTargetsUi = $("#node-input-syncTargets-ui");

	      function parseZonesText(text) {
	        const raw = String(text || "").trim();
	        if (!raw) return [];

	        const parsed = JSON.parse(raw);
	        if (!Array.isArray(parsed)) {
	          throw new Error("Zones must be a JSON array.");
	        }
	        return parsed.filter((z) => z && typeof z === "object");
	      }

      function parseSyncTargets(text) {
        const raw = String(text || "").trim();
        if (!raw) return {};
        try {
          const parsed = JSON.parse(raw);
          return parsed && typeof parsed === "object" && !Array.isArray(parsed) ? parsed : {};
        } catch (_err) {
          return {};
        }
      }

      function normalizeSyncAction(value) {
        const v = String(value || "").trim().toLowerCase();
        if (v === "arm") return "arm";
        if (v === "disarm") return "disarm";
        return "leave";
      }

      function syncActionLabel(value) {
        const v = normalizeSyncAction(value);
        if (v === "arm") return "Arm";
        if (v === "disarm") return "Disarm";
        return "Leave as is";
      }

      function escapeHtml(text) {
        return String(text || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function buildSyncTargetsUi() {
        if (!syncTargetsUi || !syncTargetsUi.length) return;
        try {
          const saved = parseSyncTargets(syncTargetsField.val());

          // Collect other Alarm nodes in the workspace.
          const other = [];
          try {
            if (RED && RED.nodes && typeof RED.nodes.eachNode === "function") {
              RED.nodes.eachNode((n) => {
                if (!n) return;
                const type = String(n.type || "");
                if (type !== "AlarmSystemUltimate") return;
                if (n.id === nodeId) return;
                other.push({ id: n.id, name: String(n.name || "").trim() });
              });
            }
          } catch (_err) { }

          other.sort((a, b) => {
            const an = (a.name || a.id).toLowerCase();
            const bn = (b.name || b.id).toLowerCase();
            return an.localeCompare(bn);
          });

          if (other.length === 0) {
            syncTargetsUi.html('<span style="color:#777;">No other Alarm nodes found.</span>');
            return;
          }

          const table = $('<table style="width:100%; border-collapse:collapse;"></table>');
          table.append(
            '<thead><tr>' +
            '<th style="text-align:left; padding:4px 6px;">Alarm</th>' +
            '<th style="text-align:left; padding:4px 6px; width:160px;">On ARM</th>' +
            '<th style="text-align:left; padding:4px 6px; width:160px;">On DISARM</th>' +
            '</tr></thead>',
          );

          const tbody = $("<tbody></tbody>");
          other.forEach((n) => {
            const rule = saved[n.id] && typeof saved[n.id] === "object" ? saved[n.id] : {};
            const onArm = normalizeSyncAction(rule.onArm);
            const onDisarm = normalizeSyncAction(rule.onDisarm);

            const armSel = $('<select style="width:100%;"></select>');
            const disarmSel = $('<select style="width:100%;"></select>');
            ["arm", "leave", "disarm"].forEach((v) => {
              armSel.append(`<option value="${v}">${syncActionLabel(v)}</option>`);
              disarmSel.append(`<option value="${v}">${syncActionLabel(v)}</option>`);
            });
            armSel.val(onArm);
            disarmSel.val(onDisarm);

            const tr = $("<tr></tr>");
            const label = n.name ? `${n.name}` : "(unnamed Alarm)";
            tr.append(
              `<td style="padding:4px 6px;">${escapeHtml(label)}</td>`,
            );
            const tdArm = $('<td style="padding:4px 6px;"></td>').append(armSel);
            const tdDisarm = $('<td style="padding:4px 6px;"></td>').append(disarmSel);
            tr.append(tdArm).append(tdDisarm);
            tbody.append(tr);

            function persist() {
              const next = parseSyncTargets(syncTargetsField.val());
              next[n.id] = {
                onArm: String(armSel.val() || "leave"),
                onDisarm: String(disarmSel.val() || "leave"),
              };
              syncTargetsField.val(JSON.stringify(next));
              try {
                syncTargetsField.trigger("change");
              } catch (_err) { }
            }

            armSel.on("change", persist);
            disarmSel.on("change", persist);
          });
          table.append(tbody);
          syncTargetsUi.empty().append(table);
        } catch (err) {
          syncTargetsUi.html(
            `<span style="color:#c00;">Unable to render sync list. Check browser console. (${escapeHtml(err && err.message ? err.message : err)})</span>`,
          );
        }
      }

      function updateZonesSummary() {
        try {
          const zones = parseZonesText(zonesField.val());
          zonesSummary.text(zones.length ? `${zones.length} zones configured` : "No zones configured");
        } catch (err) {
          zonesSummary.text("Zones: invalid JSON");
        }
      }

      function sanitizeFilenamePart(text) {
        return String(text || "")
          .trim()
          .replace(/[\\/:*?"<>|]+/g, "-")
          .replace(/\s+/g, "-")
          .replace(/-+/g, "-")
          .replace(/^-|-$/g, "")
          .slice(0, 60);
      }

      function downloadTextFile(filename, text, mimeType) {
        try {
          const blob = new Blob([String(text || "")], {
            type: mimeType || "application/octet-stream",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 0);
        } catch (err) {
          try {
            if (RED && typeof RED.notify === "function") {
              RED.notify(`Unable to download file: ${escapeHtml(err && err.message ? err.message : err)}`, "error");
            }
          } catch (_err) { }
        }
      }

      function markDirtyAndUpdateSummary() {
        try {
          zonesField.trigger("change");
        } catch (_err) { }
        try {
          if (RED && RED.nodes && typeof RED.nodes.dirty === "function") {
            RED.nodes.dirty(true);
          }
        } catch (_err) { }
        updateZonesSummary();
      }

	      function importZonesFromText(rawText) {
	        const text = String(rawText || "").trim();
	        if (!text) {
	          zonesField.val("");
	          markDirtyAndUpdateSummary();
	          return;
	        }

	        const parsedZones = parseZonesText(text);
	        const zonesTextToStore = JSON.stringify(parsedZones, null, 2);

	        // Validate imported content before saving it into the node.
	        const importedZones = parseZonesText(zonesTextToStore);
	        const existingZones = (() => {
          try {
            return parseZonesText(zonesField.val());
          } catch (_err) {
            return [];
          }
        })();

        if (existingZones.length > 0 && importedZones.length > 0) {
          const ok = window.confirm(
            `Replace the current zones (${existingZones.length}) with the imported ones (${importedZones.length})?`,
          );
          if (!ok) return;
        }

        zonesField.val(zonesTextToStore);
        markDirtyAndUpdateSummary();
      }

      function openZonesManager() {
        const httpAdminRoot = (RED.settings && RED.settings.httpAdminRoot) || "/";
        const root = httpAdminRoot.endsWith("/") ? httpAdminRoot : `${httpAdminRoot}/`;
        const currentName = String($("#node-input-name").val() || "").trim();
        const namePart = currentName ? `&name=${encodeURIComponent(currentName)}` : "";
        const idPart = nodeId ? `?id=${encodeURIComponent(nodeId)}${namePart}` : "";
        window.open(`${root}alarm-ultimate/alarm-json-mapper${idPart}`, "_blank");
      }

      $("#node-input-zones-panel").on("click", function (evt) {
        evt.preventDefault();
        const httpAdminRoot = (RED.settings && RED.settings.httpAdminRoot) || "/";
        const root = httpAdminRoot.endsWith("/") ? httpAdminRoot : `${httpAdminRoot}/`;
        const idPart = nodeId ? `?id=${encodeURIComponent(nodeId)}` : "";
        window.open(
          `${root}alarm-ultimate/alarm-panel${idPart}`,
          "_blank",
          "noopener,noreferrer",
        );
      });

      $("#node-input-zones-manage").on("click", function (evt) {
        evt.preventDefault();
        openZonesManager();
      });

      if (zonesExportBtn && zonesExportBtn.length) {
        zonesExportBtn.on("click", function (evt) {
          evt.preventDefault();
          let zones = [];
          try {
            zones = parseZonesText(zonesField.val());
          } catch (err) {
            try {
              if (RED && typeof RED.notify === "function") {
                RED.notify(`Zones JSON is invalid: ${escapeHtml(err && err.message ? err.message : err)}`, "error");
              }
            } catch (_err) { }
            return;
          }

          const nodeName = String($("#node-input-name").val() || "").trim() || initialNodeName;
          const safeName = sanitizeFilenamePart(nodeName);
          const stamp = new Date().toISOString().replace(/[:.]/g, "-");
          const filename = `alarm-ultimate-zones${safeName ? `-${safeName}` : ""}-${stamp}.json`;
          downloadTextFile(filename, JSON.stringify(zones, null, 2) + "\n", "application/json;charset=utf-8");
        });
      }

      if (zonesImportBtn && zonesImportBtn.length && zonesImportFile && zonesImportFile.length) {
        zonesImportBtn.on("click", function (evt) {
          evt.preventDefault();
          try {
            zonesImportFile.val("");
          } catch (_err) { }
          zonesImportFile.trigger("click");
        });

        zonesImportFile.on("change", function () {
          const file = this && this.files && this.files[0] ? this.files[0] : null;
          if (!file) return;

          const reader = new FileReader();
          reader.onload = () => {
            try {
              importZonesFromText(reader.result);
              try {
                if (RED && typeof RED.notify === "function") {
                  RED.notify(`Zones imported (${file.name})`, "success");
                }
              } catch (_err) { }
            } catch (err) {
              try {
                if (RED && typeof RED.notify === "function") {
                  RED.notify(`Unable to import zones: ${escapeHtml(err && err.message ? err.message : err)}`, "error");
                }
              } catch (_err) { }
            } finally {
              try {
                zonesImportFile.val("");
              } catch (_err) { }
            }
          };
          reader.onerror = () => {
            try {
              if (RED && typeof RED.notify === "function") {
                RED.notify(`Unable to read file: ${escapeHtml(file.name)}`, "error");
              }
            } catch (_err) { }
            try {
              zonesImportFile.val("");
            } catch (_err) { }
          };
          reader.readAsText(file);
        });
      }

      const messageListener = (evt) => {
        if (!evt || evt.origin !== openerOrigin) return;
        const data = evt.data && typeof evt.data === "object" ? evt.data : null;
        if (!data || typeof data.type !== "string") return;
        if (data.nodeId && data.nodeId !== nodeId) return;

        if (data.type === "alarm-ultimate-request-zones") {
          let zonesJson = "";
          try {
            const zones = parseZonesText(zonesField.val());
            zonesJson = zones.length ? JSON.stringify(zones, null, 2) : "";
          } catch (_err) {
            zonesJson = "";
          }
          try {
            evt.source.postMessage(
              {
                type: "alarm-ultimate-zones",
                nodeId,
                nodeName: String($("#node-input-name").val() || "").trim() || String(this.name || ""),
                zonesJson,
              },
              openerOrigin,
            );
          } catch (_err) {
            // ignore
          }
          try {
            if (bc) {
              bc.postMessage({
                type: "alarm-ultimate-zones",
                nodeId,
                nodeName: String($("#node-input-name").val() || "").trim() || String(this.name || ""),
                zonesJson,
              });
            }
          } catch (_err) {
            // ignore
          }
          return;
        }

        if (data.type === "alarm-ultimate-zones" && typeof data.zonesJson === "string") {
          zonesField.val(String(data.zonesJson || ""));
          try {
            zonesField.trigger("change");
          } catch (_err) {
            // ignore
          }
          try {
            if (RED && RED.nodes && typeof RED.nodes.dirty === "function") {
              RED.nodes.dirty(true);
            }
          } catch (_err) {
            // ignore
          }
          updateZonesSummary();
        }
      };

      window.addEventListener("message", messageListener);
      if (bc) {
        bc.addEventListener("message", (ev) => {
          const data = ev && ev.data && typeof ev.data === "object" ? ev.data : null;
          if (!data || typeof data.type !== "string") return;
          if (data.nodeId && data.nodeId !== nodeId) return;
          // Reuse the same handler surface by calling it with a minimal shape.
          messageListener({ origin: openerOrigin, data, source: null });
        });
        this._alarmUltimateZonesBroadcast = bc;
      }
      this._alarmUltimateZonesMessageListener = messageListener;
      updateZonesSummary();
      setTimeout(() => buildSyncTargetsUi(), 0);
    },
    oneditsave: function () {
      if (this._alarmUltimateZonesMessageListener) {
        window.removeEventListener("message", this._alarmUltimateZonesMessageListener);
        this._alarmUltimateZonesMessageListener = null;
      }
      if (this._alarmUltimateZonesBroadcast) {
        try {
          this._alarmUltimateZonesBroadcast.close();
        } catch (_err) {
          // ignore
        }
        this._alarmUltimateZonesBroadcast = null;
      }
      this.sirenOnPayloadType = $("#node-input-sirenOnPayload").typedInput(
        "type",
      );
      this.sirenOffPayloadType = $("#node-input-sirenOffPayload").typedInput(
        "type",
      );
    },
    oneditcancel: function () {
      if (this._alarmUltimateZonesMessageListener) {
        window.removeEventListener("message", this._alarmUltimateZonesMessageListener);
        this._alarmUltimateZonesMessageListener = null;
      }
      if (this._alarmUltimateZonesBroadcast) {
        try {
          this._alarmUltimateZonesBroadcast.close();
        } catch (_err) {
          // ignore
        }
        this._alarmUltimateZonesBroadcast = null;
      }
    },
  });
</script>

	<script type="text/html" data-template-name="AlarmSystemUltimate">
	  <style>
	    .alarm-ultimate-editor .red-ui-button.au-btn {
	      border-radius: 8px;
	      font-weight: 600;
	      border-width: 1px;
	    }

    .alarm-ultimate-editor .red-ui-button.au-btn i {
      margin-right: 4px;
    }

    .alarm-ultimate-editor .red-ui-button.au-btn-primary {
      background: #2563eb !important;
      border-color: #1d4ed8 !important;
      color: #fff !important;
    }
    .alarm-ultimate-editor .red-ui-button.au-btn-primary:hover {
      background: #1d4ed8 !important;
    }

    .alarm-ultimate-editor .red-ui-button.au-btn-success {
      background: #16a34a !important;
      border-color: #15803d !important;
      color: #fff !important;
    }
	    .alarm-ultimate-editor .red-ui-button.au-btn-success:hover {
	      background: #15803d !important;
	    }

	    .alarm-ultimate-editor .au-tab {
	      padding-top: 6px;
	    }
	  </style>

		  <div class="alarm-ultimate-editor">
		  <div class="form-row">
		    <b>Alarm System Ultimate (BETA)</b>
	    &nbsp;&nbsp;<span style="color:red"
	      ><i class="fa fa-question-circle"></i>&nbsp;<a
	        target="_blank"
	        href="https://github.com/Supergiovane/node-red-contrib-alarm-ultimate"
	        ><u>Help online</u></a
	      ></span
	    >
	    &nbsp;&nbsp;<span style="color:#cc0000"
	      ><i class="fa fa-youtube-play"></i>&nbsp;<a
	        target="_blank"
	        href="https://youtu.be/HUPzhVgObBE"
	        ><u>YOUTUBE</u></a
	      ></span
		    >
		  </div>

		  <div class="form-row">
		    <ul style="min-width:600px; margin-bottom: 12px;" id="node-input-au-tabs"></ul>
		  </div>

		  <div id="node-input-au-tabs-content" style="min-height: 400px;">
		    <div id="node-input-au-tab-zones" class="au-tab" style="display:none;">
		      <div class="form-row">
		        <label>WEB PAGE</label>
		        <button
		          type="button"
		          class="red-ui-button au-btn au-btn-primary"
		          id="node-input-zones-panel"
		        >
		          <i class="fa fa-keyboard-o"></i> Panel
		        </button>
		      </div>

		      <div class="form-row">
		        <label><i class="fa fa-th-large"></i> Zones</label>
		        <button
		          type="button"
		          class="red-ui-button au-btn au-btn-success"
		          id="node-input-zones-manage"
		        >
		          <i class="fa fa-list"></i> Manage zones
		        </button>
            <button
              type="button"
              class="red-ui-button au-btn"
              id="node-input-zones-export"
              style="margin-left:6px;"
            >
              <i class="fa fa-download"></i> Export JSON
            </button>
            <button
              type="button"
              class="red-ui-button au-btn"
              id="node-input-zones-import"
              style="margin-left:6px;"
            >
              <i class="fa fa-upload"></i> Import JSON
            </button>
            <input
              type="file"
              id="node-input-zones-import-file"
              accept="application/json,.json"
              style="display:none;"
            />
		        <span id="node-input-zones-summary" style="margin-left:8px; color:#777;"></span>
		      </div>

		      <textarea id="node-input-zones" style="display:none;"></textarea>
		    </div>

		    <div id="node-input-au-tab-general" class="au-tab" style="display:none;">
		      <div class="form-row">
		        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
		        <input type="text" id="node-input-name" placeholder="Name" />
		      </div>

		      <div class="form-row">
		        <label for="node-input-controlTopic"
		          ><i class="fa fa-tag"></i> Control topic</label
		        >
		        <input type="text" id="node-input-controlTopic" />
		      </div>

		      <div class="form-row">
		        <label for="node-input-payloadPropName"
		          ><i class="fa fa-ellipsis-h"></i> With Input</label
		        >
		        <input type="text" id="node-input-payloadPropName" />
		      </div>

		      <div class="form-row">
		        <label><i class="fa fa-random"></i> Sync other alarms</label>
		        <div style="width: 70%;">
		          <div class="form-tips" style="margin: 0 0 6px 0;">
		            When this Alarm is armed/disarmed, optionally arm/disarm other Alarm nodes in the workspace (codes are forwarded if present).
		          </div>
		          <div id="node-input-syncTargets-ui"></div>
		          <input type="hidden" id="node-input-syncTargets" />
		        </div>
		      </div>

		      <div class="form-row">
		        <label for="node-input-persistState"
		          ><i class="fa fa-database"></i> Persist state</label
		        >
		        <input
		          type="checkbox"
		          id="node-input-persistState"
		          style="width:auto; margin-top:7px;"
		        />
		      </div>
		    </div>

		    <div id="node-input-au-tab-security" class="au-tab" style="display:none;">
		      <div class="form-row">
		        <label for="node-input-requireCodeForArm"
		          ><i class="fa fa-lock"></i> Require code for arm</label
		        >
		        <input
		          type="checkbox"
		          id="node-input-requireCodeForArm"
		          style="width:auto; margin-top:7px;"
		        />
		      </div>

		      <div class="form-row">
		        <label for="node-input-requireCodeForDisarm"
		          ><i class="fa fa-unlock"></i> Require code for disarm</label
		        >
		        <input
		          type="checkbox"
		          id="node-input-requireCodeForDisarm"
		          style="width:auto; margin-top:7px;"
		        />
		      </div>

		      <div class="form-row">
		        <label for="node-input-armCode"
		          ><i class="fa fa-key"></i> Code</label
		        >
		        <input type="password" id="node-input-armCode" placeholder="(optional)" />
		      </div>

	    <div class="form-row">
		    <label for="node-input-duressCode"
		        ><i class="fa fa-user-secret"></i> Duress code</label
		      >
      <input
        type="password"
        id="node-input-duressCode"
        placeholder="(optional)"
      />
    </div>

    <div class="form-row">
	      <label
	        for="node-input-blockArmOnViolations"
	        ><i class="fa fa-shield"></i> Block arm on violations</label
	      >
      <input
        type="checkbox"
        id="node-input-blockArmOnViolations"
	        style="width:auto; margin-top:7px;"
	      />
	    </div>

	    <hr />

	    <div class="form-row">
	      <label
	        for="node-input-exitDelaySeconds"
	        ><i class="fa fa-sign-out"></i> Exit delay (s)</label
	      >
	      <input type="number" id="node-input-exitDelaySeconds" min="0" />
	    </div>

	    <div class="form-row">
	      <label
	        for="node-input-entryDelaySeconds"
	        ><i class="fa fa-sign-in"></i> Entry delay (s)</label
	      >
		      <input type="number" id="node-input-entryDelaySeconds" min="0" />
		    </div>

		    </div>

		    <div id="node-input-au-tab-siren" class="au-tab" style="display:none;">
		      <div class="form-row">
		        <label for="node-input-sirenTopic"
		          ><i class="fa fa-bullhorn"></i> Siren topic</label
		        >
		        <input type="text" id="node-input-sirenTopic" placeholder="siren" />
		      </div>

		      <div class="form-row">
		        <label for="node-input-sirenDurationSeconds"
		          ><i class="fa fa-clock-o"></i> Siren duration (s)</label
		        >
		        <input type="number" id="node-input-sirenDurationSeconds" min="0" />
		      </div>

		      <div class="form-row">
		        <label for="node-input-sirenLatchUntilDisarm"
		          ><i class="fa fa-link"></i> Latch siren until disarm</label
		        >
		        <input
		          type="checkbox"
		          id="node-input-sirenLatchUntilDisarm"
		          style="width:auto; margin-top:7px;"
		        />
		      </div>

		      <div class="form-row">
		        <label for="node-input-sirenOnPayload"
		          ><i class="fa fa-play"></i> Siren ON payload</label
		        >
		        <input type="text" id="node-input-sirenOnPayload" />
		      </div>

		      <div class="form-row">
		        <label for="node-input-sirenOffPayload"
		          ><i class="fa fa-stop"></i> Siren OFF payload</label
		        >
		        <input type="text" id="node-input-sirenOffPayload" />
		      </div>
		    </div>

		    <div id="node-input-au-tab-open-zones" class="au-tab" style="display:none;">
		      <div class="form-row">
		        <b>Open zones listing</b>
		      </div>

		      <div class="form-row">
		        <label for="node-input-emitOpenZonesDuringArming"
		          ><i class="fa fa-list"></i> Emit open zones while arming</label
		        >
		        <input
		          type="checkbox"
		          id="node-input-emitOpenZonesDuringArming"
		          style="width:auto; margin-top:7px;"
		        />
		      </div>

		      <div class="form-row">
		        <label for="node-input-openZonesArmingIntervalSeconds"
		          ><i class="fa fa-clock-o"></i> Arming list interval (s)</label
		        >
		        <input
		          type="number"
		          id="node-input-openZonesArmingIntervalSeconds"
		          min="0"
		          step="0.1"
		        />
		      </div>

		      <div class="form-row">
		        <label for="node-input-openZonesRequestTopic"
		          ><i class="fa fa-list"></i> Open zones request topic</label
		        >
		        <input
		          type="text"
		          id="node-input-openZonesRequestTopic"
		          placeholder="alarm/listOpenZones"
		        />
		      </div>

		      <div class="form-row">
		        <label for="node-input-openZonesRequestIntervalSeconds"
		          ><i class="fa fa-clock-o"></i> Request list interval (s)</label
		        >
		        <input
		          type="number"
		          id="node-input-openZonesRequestIntervalSeconds"
		          min="0"
		          step="0.1"
		        />
		      </div>

		      <hr />

		      <div class="form-row">
		        <label for="node-input-emitOpenZonesCycle"
		          ><i class="fa fa-refresh"></i> Cycle open zones (always)</label
		        >
		        <input
		          type="checkbox"
		          id="node-input-emitOpenZonesCycle"
		          style="width:auto; margin-top:7px;"
		        />
		      </div>

		      <div class="form-row">
		        <label for="node-input-openZonesCycleIntervalSeconds"
		          ><i class="fa fa-clock-o"></i> Cycle interval (s)</label
		        >
		        <input
		          type="number"
		          id="node-input-openZonesCycleIntervalSeconds"
		          min="0"
		          step="0.1"
		        />
		      </div>
		    </div>

		    <div id="node-input-au-tab-advanced" class="au-tab" style="display:none;">
		      <div class="form-row">
		        <label for="node-input-emitRestoreEvents"
		          ><i class="fa fa-undo"></i> Emit restore events</label
		        >
		        <input
		          type="checkbox"
		          id="node-input-emitRestoreEvents"
		          style="width:auto; margin-top:7px;"
		        />
		      </div>

		      <div class="form-row">
		        <label for="node-input-maxLogEntries"
		          ><i class="fa fa-list"></i> Event log size</label
		        >
		        <input type="number" id="node-input-maxLogEntries" min="0" max="500" />
		      </div>
		    </div>
		  </div>
	  </div>
				</script>

<script type="text/markdown" data-help-name="AlarmSystemUltimate">
  <p><b>BETA</b> – Alarm control panel node with a single armed/disarmed state, zones, entry/exit delays, bypass, chime, tamper/fire/24h zones, siren control, status and event log.</p>

  ## Quick start (5 minutes)

  1. Add an **Alarm System (BETA)** node to your flow.
  2. Click **Manage zones** and create at least one zone (example topic: `sensor/frontdoor`). Use **Export JSON** / **Import JSON** in the Zones tab to backup/restore your zones.  
     **Important:** after editing zones, click **Done** in the Node-RED editor to save (if you click **Cancel**, changes are lost).
  3. Send sensor messages to the Alarm node:
     - open: `msg.topic="sensor/frontdoor"` + `msg.payload=true` (also works: `"open"`, `"on"`, `1`)
     - close: `msg.topic="sensor/frontdoor"` + `msg.payload=false` (also works: `"closed"`, `"off"`, `0`)
  4. To arm/disarm, send a control message where `msg.topic` equals **Control topic** (default `alarm`):
     - arm: `msg.command="arm"`
     - disarm: `msg.command="disarm"`
  5. Attach a **Debug** node to see what the Alarm outputs.

  Tip (recommended): use **Alarm Zone** / **Alarm State** in **Input** mode to normalize incoming data (KNX/HomeKit/...) and inject it into the selected Alarm node. Use **Alarm Zone** / **Alarm State** in **Output** mode with an **Adapter** to filter/transform Alarm outputs (HomeKit, KNX, AX Pro, ...).

  The node has 2 inputs "in one":

  - **Control messages**: when `msg.topic` equals **Control topic**.
  - **Sensor messages**: any other message, matched to a zone by `msg.topic` and converted to boolean using **With Input** (default `payload`).

  Tip: Use one or more **Alarm Zone** / **Alarm State** nodes (Output mode + Adapter) to filter/transform Alarm outputs (zone activity, HomeKit/KNX/AX Pro, ...).

  <br/>

  ### WEB PAGE

  - **Panel**: `/alarm-ultimate/alarm-panel` (supports `?id=<alarmNodeId>` and `?embed=1&id=<alarmNodeId>`).
  - **Zones**: use **Manage zones** to open `/alarm-ultimate/alarm-json-mapper` and sync the JSON back into the editor. Click **Done** in the editor to apply/save. Use **Export JSON** / **Import JSON** to backup/restore zone definitions.
  - **Name**: optional label shown in the Alarm Panel.
  - **Control topic**: topic that receives commands (and is used as base for some outputs).
  - **With Input**: message property evaluated as sensor value (default `payload`). It must be convertible to boolean (`true/false`, `open/closed`, `on/off`, `1/0`, ...).

  <br/>

  ### Settings

  | Property                     | Description                                                                                                                          |
  | ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
  | Persist state                | Persists arming state, bypass list and event log across restarts.                                                                    |
  | Require code for arm         | Requires a valid PIN for arming commands (via `msg.code`). If **Code** is empty, commands are allowed.                               |
  | Require code for disarm      | Requires a valid PIN for disarming commands (via `msg.code`). If **Code** is empty, commands are allowed.                            |
  | Code                         | PIN required to arm/disarm when enabled.                                                                                             |
  | Duress code                  | If provided and `msg.code` matches, the node raises a silent duress alarm while still executing the command.                         |
  | Block arm on violations      | Prevents arming if any active (true) zone would be armed (excluding bypassed zones). Checked both at arm start and after exit delay. |
  | Exit/Entry delay (s)         | Global exit/entry delays (each zone can override entry delay).                                                                       |
  | Emit open zones while arming | Emits open zones one-by-one while arming (during exit delay).                                                                        |
  | Arming list interval (s)     | Interval between each open zone emitted while arming.                                                                                |
  | Open zones request topic     | When a message arrives with `msg.topic` equal to this topic, the node lists open zones even while disarmed.                          |
  | Request list interval (s)    | Interval between each open zone emitted on request (0 = send immediately).                                                           |
  | Cycle open zones (always)    | Cycles open zones one-by-one at a fixed interval, regardless of alarm state.                                                         |
  | Cycle interval (s)           | Interval between each open zone emitted by the cycle (0 = disabled).                                                                 |
  | Siren topic                  | Topic used to turn the siren on/off (default: `controlTopic + "/siren"`).                                                             |
  | Siren ON/OFF payload         | Values emitted for siren on/off (typed).                                                                                             |
  | Siren duration (s)           | Auto stop duration (`0` = latch until disarm).                                                                                       |
  | Latch siren until disarm     | Forces siren to remain on until disarm (ignores duration).                                                                           |
  | Emit restore events          | Emits `zone_restore` when a zone returns to false.                                                                                   |
  | Event log size               | Max stored log entries in node context (0 disables log).                                                                             |
  | Sync other alarms            | Optional: when this node is armed/disarmed, it can arm/disarm other Alarm nodes. The original `msg.code` is forwarded.               |
  | Zones                        | Zone definitions. Use **Manage zones** (web tool) to edit advanced JSON (including optional supervision). Use **Export JSON** / **Import JSON** to backup/restore. |

  <br/>

  ## Zones JSON (advanced)

  Each zone can optionally enable **sensor supervision** (per-zone): if no valid sensor updates are received within `timeoutSeconds`, the node emits `supervision_lost` (supervision starts immediately when the node runs, and `supervision_restored` is emitted on the next valid update).

  Example:

  ```json
  {
    "name": "Front door",
    "topic": "sensor/frontdoor",
    "type": "perimeter",
    "supervision": { "enabled": true, "timeoutSeconds": 120, "blockArm": true }
  }
  ```

  <br/>

  ## Output

  The node has **10 outputs** (pins). Output **#1 (All messages)** is a superset and always emits everything.

  1. **All messages** (superset)
  2. **Siren**
  3. **Alarm triggered**
  4. **Arm/Disarm updates**
  5. **Zone activity**
  6. **Errors/Denied**
  7. **Any zone open**
  8. **Open zones (arming)**
  9. **Open zones (on request)**
  10. **Open zones (cycle)**

  **Event messages**

  - `msg.topic = controlTopic + "/event"`
  - `msg.event` (string) and `msg.payload` (object)

  `msg.payload` always contains at least:

  - `event`: same as `msg.event`
  - `mode`: `disarmed|armed`

  **Siren messages**

  - `msg.topic = sirenTopic` (default: `controlTopic + "/siren"`)
  - `msg.payload`: configured siren ON/OFF payload (typed)
  - `msg.event`: `siren_on` / `siren_off`
  - `msg.reason`: why it changed (`manual`, `panic`, `instant`, `entry_timeout`, `timeout`, `disarm`, ...)

  **Any zone open**

  - `msg.topic = controlTopic + "/anyZoneOpen"`
  - `msg.payload = true|false`
  - `msg.openZonesCount` and `msg.openZones` (array)

  **Open zones listing**

  - `msg.topic = controlTopic + "/openZone"`
  - `msg.event = "open_zone"`
  - `msg.payload = { context, position, total, zone }` where `context` can be `arming`, `request` or `cycle`

  <br/>

  ## Events (`msg.event`)

  Arming / state:

  - `arming` → `{ target, seconds, reason }`
  - `armed` → `{ reason }`
  - `disarmed` → `{ reason, duress }`
  - `already_armed` → `{ target }`
  - `arm_blocked` → `{ target, violations:[{name,type,topic,open,supervisionLost}] }`
  - `status` → `{ state: { mode, arming, entry, alarmActive, silentAlarmActive, sirenActive, alarmZone, bypassedZones, log } }`
  - `reset` → `{}`
  - `denied` → `{ action: "arm"|"disarm", target? }`
  - `error` → `{ error: "missing_zone"|"unknown_zone"|"zone_not_bypassable", zone? }`

  Zones / alarm:

  - `entry_delay` → `{ zone:{name,type,topic}, seconds }`
  - `alarm` → `{ kind, zone, silent }` where `kind` can be `instant|entry_timeout|panic|duress|fire|tamper|24h|...`
  - `chime` → `{ zone:{name,type,topic} }` (while disarmed)
  - `zone_open` → `{ zone:{name,type,topic}, open:true, bypassed }` (always)
  - `supervision_lost` → `{ zone:{name,type,topic}, timeoutSeconds, lastSeenAt }`
  - `supervision_restored` → `{ zone:{name,type,topic}, timeoutSeconds, lastSeenAt }`
  - `zone_close` → `{ zone:{name,type,topic}, open:false, bypassed }` (always)
  - `zone_ignored_exit` → `{ zone:{name,type,topic} }` (triggered during exit delay and not allowed)
  - `zone_bypassed_trigger` → `{ zone:{name,type,topic} }`
  - `zone_restore` → `{ zone:{name,type,topic} }` (when enabled)
  - `siren_on` → `{ reason }` (manual `siren_on` command)
  - `siren_off` → `{ reason }` (manual stop, disarm, timeout, arm, ...)
  - `open_zone` → `{ context, position, total, zone }` (open zones listing outputs)

  <br/>

  ## Control messages (`msg.topic === controlTopic`)

  Arm:

  - `msg.command = "arm"`
  - or `msg.arm = "armed"`
  - or `msg.mode = "armed"`

  Disarm:

  - `msg.command = "disarm"` or `msg.disarm = true`

  Status snapshot:

  - `msg.command = "status"` or `msg.status = true`

	  List open zones (one message per zone on the node output):

  - `msg.command = "list_open_zones"` or `msg.listOpenZones = true`
  - or send a message with `msg.topic = <Open zones request topic>` (works even while disarmed)

	  Bypass / unbypass (zone topic):

  - `msg.command = "bypass"` / `msg.command = "unbypass"`
  - or `msg.bypass = true` / `msg.unbypass = true`
		  - pass the zone **topic** in `msg.zoneTopic`

  Siren:

  - `msg.command = "siren_on"|"siren_off"`

  Panic:

  - `msg.command = "panic"` (audible)
  - `msg.command = "panic_silent"` (silent)

  Reset:

  - `msg.command = "reset"` or `msg.reset = true` (clears state, bypass list, log and timers)

  Codes:

  - pass `msg.code` when code checks are enabled
  - if `msg.code` equals **Duress code**, the node emits a silent duress alarm while still arming/disarming

  <br/>

  ## Zones

	  Zones must be configured as a JSON array of objects.

	  Minimal fields:

	  - `topic` (exact topic, or a prefix ending with `*`)

	  Common fields:

		  - `topic`: **unique identifier** of the zone (used for bypass via `msg.zoneTopic`)
	  - `name`: label used in events (optional; defaults to `topic`)
  - `type`: `perimeter` (default), `motion`, `tamper`, `fire`, `24h`
  - `entry`: `true` to use entry delay, otherwise triggers instantly
  - `entryDelaySeconds`: overrides the global entry delay
  - `bypassable`: `true|false` (default `true`)
  - `chime`: `true` to emit `chime` event while disarmed
  - `cooldownSeconds`: minimum time between triggers
  - `instantDuringExit`: if true, the zone can trigger during exit delay

  Notes:

  - `tamper`, `fire` and `24h` zones are considered **always active** (they can alarm even while disarmed).
  - If a zone is bypassed, triggers generate `zone_bypassed_trigger` and do not alarm.

  Example (formatted JSON array):

	  ```json
	  [
	    {
	      "name": "Front door",
	      "topic": "house/door/front",
	      "type": "perimeter",
	      "entry": true,
      "entryDelaySeconds": 30,
      "bypassable": true,
      "chime": true
    }
  ]
  ```

  <br/>

  [SEE THE README FOR FULL HELP AND SAMPLES](https://github.com/Supergiovane/node-red-contrib-alarm-ultimate)<br/>

  [Find it useful?](https://www.paypal.me/techtoday)
</script>
