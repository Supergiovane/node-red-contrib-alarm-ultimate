<script type="text/javascript">
  RED.nodes.registerType("AlarmUltimateOutputAdapter", {
    category: "Alarm Ultimate",
    color: "#A8DADC",
    defaults: {
      name: { value: "" },
      alarmId: { value: "", required: true },
      presetSource: { value: "builtin" },
      presetId: { value: "passthrough" },
      userCode: { value: "return msg;", required: false },
    },
    inputs: 0,
    outputs: 1,
    icon: "alarm-ultimate.svg",
    label: function () {
      return this.name || "Output Adapter";
    },
    paletteLabel: function () {
      return "Output Adapter";
    },
    oneditprepare: function () {
      const self = this;
      const els = {
        alarmId: $("#node-input-alarmId"),
        presetSource: $("#node-input-presetSource"),
        presetId: $("#node-input-presetId"),
        builtinPreset: $("#node-input-builtinPreset"),
        builtinInfo: $("#node-input-builtinInfo"),
        userCode: $("#node-input-userCode"),
      };

      const panelButton = $("#node-input-alarm-panel");

      let builtinPresets = [];
      let editor = null;
      let userCodeCache = String(self.userCode || "return msg;");
      let builtinIdCache = String(self.presetId || "passthrough");

      function refreshBuiltinSelect() {
        els.builtinPreset.empty();
        builtinPresets.forEach((p) => {
          els.builtinPreset.append(
            $("<option></option>").attr("value", p.id).text(p.name),
          );
        });
      }

      function builtinExists(id) {
        const target = String(id || "").trim();
        if (!target) return false;
        return builtinPresets.some((p) => p && p.id === target);
      }

      function setMode(mode) {
        const m = mode === "user" ? "user" : "builtin";
        els.presetSource.val(m);
        $("#builtin-row").toggle(m === "builtin");
        $("#code-label-row").toggle(m === "user");
        $("#code-editor-row").toggle(m === "user");
      }

      function setBuiltinInfo(presetId) {
        const p = builtinPresets.find((x) => x.id === presetId);
        if (!p) {
          els.builtinInfo.text("");
          return;
        }
        const desc = p.description ? ` — ${p.description}` : "";
        els.builtinInfo.text(`${p.name}${desc}`);
      }

      function getSelectedBuiltinPreset() {
        const id = String(els.builtinPreset.val() || "").trim();
        return builtinPresets.find((p) => p && p.id === id) || null;
      }

      function applyBuiltinSelection(desiredId) {
        let id = String(desiredId || "").trim();
        if (!builtinExists(id)) {
          id = builtinExists(builtinIdCache) ? builtinIdCache : "passthrough";
        }
        if (!builtinExists(id) && builtinPresets.length > 0) {
          id = String(builtinPresets[0].id || "").trim();
        }
        if (builtinExists(id)) {
          els.builtinPreset.val(id);
          builtinIdCache = id;
          return id;
        }
        return "";
      }

      function updateEditor() {
        const src = els.presetSource.val() === "user" ? "user" : "builtin";
        if (src === "builtin") {
          editor.setReadOnly(true);
          return;
        }
        editor.setReadOnly(false);
        editor.setValue(String(userCodeCache || "return msg;"), -1);
      }

      editor = RED.editor.createEditor({
        id: "node-input-code-editor",
        mode: "ace/mode/javascript",
        value: userCodeCache,
      });
      self._outputAdapterEditor = editor;

      function loadBuiltins() {
        const httpAdminRoot =
          (RED.settings && RED.settings.httpAdminRoot) || "/";
        const root = httpAdminRoot.endsWith("/")
          ? httpAdminRoot
          : `${httpAdminRoot}/`;
        $.getJSON(`${root}alarm-ultimate/output-adapter/presets`)
          .done((data) => {
            builtinPresets = Array.isArray(data && data.presets)
              ? data.presets
              : [];
            refreshBuiltinSelect();
            const configured = String(els.presetId.val() || "").trim();
            const selected = applyBuiltinSelection(configured || builtinIdCache);
            if (els.presetSource.val() !== "user" && selected) {
              els.presetId.val(selected);
              setBuiltinInfo(selected);
            }
            updateEditor();
          })
          .fail(() => {
            builtinPresets = [
              {
                id: "passthrough",
                name: "Passthrough",
                description: "",
                code: "return msg;",
              },
            ];
            refreshBuiltinSelect();
            const configured = String(els.presetId.val() || "").trim();
            const selected = applyBuiltinSelection(configured || builtinIdCache);
            if (selected) setBuiltinInfo(selected);
            updateEditor();
          });
      }

      function loadAlarmNodes() {
        const httpAdminRoot = (RED.settings && RED.settings.httpAdminRoot) || "/";
        const root = httpAdminRoot.endsWith("/") ? httpAdminRoot : `${httpAdminRoot}/`;
        const url = `${root}alarm-ultimate/alarm/nodes`;
        try {
          $.getJSON(url)
            .done((data) => {
              const nodes = Array.isArray(data && data.nodes) ? data.nodes : [];
              els.alarmId.empty();
              els.alarmId.append($("<option></option>").attr("value", "").text("-- select --"));
              nodes.forEach((n) => {
                const label = n.name ? `${n.name} (${n.id})` : n.id;
                els.alarmId.append($("<option></option>").attr("value", n.id).text(label));
              });
              if (self.alarmId) els.alarmId.val(self.alarmId);
            })
            .fail(() => {});
        } catch (_err) {}
      }

      // Initialize.
      loadBuiltins();
      loadAlarmNodes();
      setMode(els.presetSource.val());

      // Seed selects from stored presetId.
      const initialSource =
        els.presetSource.val() === "user" ? "user" : "builtin";
      const initialId = String(els.presetId.val() || "");
      if (initialSource === "builtin") {
        builtinIdCache = String(initialId || builtinIdCache || "passthrough");
      }
      if (!els.userCode.val()) {
        els.userCode.val(userCodeCache);
      } else {
        userCodeCache = String(els.userCode.val() || "return msg;");
      }
      updateEditor();

      panelButton.off("click").on("click", (evt) => {
        evt.preventDefault();
        const httpAdminRoot = (RED.settings && RED.settings.httpAdminRoot) || "/";
        const root = httpAdminRoot.endsWith("/") ? httpAdminRoot : `${httpAdminRoot}/`;
        const alarmId = els.alarmId.val() || self.alarmId || "";
        const idPart = alarmId ? `?id=${encodeURIComponent(alarmId)}` : "";
        window.open(
          `${root}alarm-ultimate/alarm-panel${idPart}`,
          "_blank",
          "noopener,noreferrer",
        );
      });

      // Events.
      els.presetSource.on("change", () => {
        // keep user draft before switching away
        if (editor && editor.getReadOnly && editor.getReadOnly() === false) {
          userCodeCache = String(editor.getValue() || "");
          els.userCode.val(userCodeCache);
        }
        const m = els.presetSource.val() === "user" ? "user" : "builtin";
        setMode(m);
        if (m === "builtin") {
          const selected = applyBuiltinSelection(
            els.builtinPreset.val() || builtinIdCache,
          );
          if (selected) {
            els.presetId.val(selected);
            setBuiltinInfo(selected);
          }
        } else {
          builtinIdCache = String(els.builtinPreset.val() || builtinIdCache);
          els.presetId.val("custom");
        }
        updateEditor();
      });

      els.builtinPreset.on("change", () => {
        const id = String(els.builtinPreset.val() || "");
        builtinIdCache = id;
        els.presetId.val(id);
        setBuiltinInfo(id);
        updateEditor();
      });

      editor.getSession().on("change", () => {
        const src = els.presetSource.val() === "user" ? "user" : "builtin";
        if (src !== "user") return;
        userCodeCache = String(editor.getValue() || "");
        els.userCode.val(userCodeCache);
      });
    },
    oneditsave: function () {
      // Keep presetId aligned with current selection.
      const src =
        $("#node-input-presetSource").val() === "user" ? "user" : "builtin";
      if (src === "builtin") {
        $("#node-input-presetId").val(
          String($("#node-input-builtinPreset").val() || ""),
        );
      } else {
        $("#node-input-presetId").val("custom");
      }
      if (this._outputAdapterEditor && src === "user") {
        $("#node-input-userCode").val(
          String(this._outputAdapterEditor.getValue() || ""),
        );
      }
      if (this._outputAdapterEditor) {
        try {
          this._outputAdapterEditor.destroy();
        } catch (_err) {
          // ignore
        }
        this._outputAdapterEditor = null;
      }
    },
    oneditcancel: function () {
      if (this._outputAdapterEditor) {
        try {
          this._outputAdapterEditor.destroy();
        } catch (_err) {
          // ignore
        }
        this._outputAdapterEditor = null;
      }
    },
  });
</script>

<script type="text/html" data-template-name="AlarmUltimateOutputAdapter">
  <div class="form-row">
    <label>WEB PAGE</label>
    <button type="button" class="red-ui-button" id="node-input-alarm-panel">
      <i class="fa fa-keyboard-o"></i> Panel
    </button>
  </div>

  <div class="form-row">
    <label for="node-input-name"><i class="icon-tag"></i> Name</label>
    <input type="text" id="node-input-name" placeholder="Name" />
  </div>

  <div class="form-row">
    <label for="node-input-alarmId"><i class="fa fa-link"></i> Alarm node</label>
    <select id="node-input-alarmId" style="width: 70%"></select>
  </div>

  <br />

  <div class="form-row">
    <label for="node-input-presetSource"
      ><i class="fa fa-random"></i> Preset source</label
    >
    <select id="node-input-presetSource" style="width: 70%;">
      <option value="builtin">Built-in</option>
      <option value="user">User</option>
    </select>
  </div>

  <br />

  <div class="form-row" id="builtin-row">
    <label for="node-input-builtinPreset"
      ><i class="fa fa-sign-out"></i> Output</label
    >
    <select id="node-input-builtinPreset" style="width: 70%;"></select>
    <br />
    <br />
    <div class="form-tips" id="node-input-builtinInfo"></div>
  </div>

  <div class="form-row" id="code-label-row">
    <label><i class="fa fa-code"></i> Code</label>
  </div>

  <div class="form-row" id="code-editor-row">
    <div style="width:100%;">
      <div
        style="height: 320px; width: 100%;"
        class="node-text-editor"
        id="node-input-code-editor"
      ></div>
      <br />
      <div class="form-tips">
        Built-in presets are read-only. Switch to <b>User</b> to edit your
        custom code. Return a msg, an array of msgs, or nothing to drop.
      </div>
    </div>
  </div>

  <input type="hidden" id="node-input-userCode" />
  <input type="hidden" id="node-input-presetId" />
  <br />
  <br />
  <br />
  <br />
</script>

<script type="text/markdown" data-help-name="AlarmUltimateOutputAdapter">
  Sends Alarm events/state to other systems (HomeKit, MQTT, dashboards, TTS, ...), using presets.

  ## Quick start

  1. Drop an **Output Adapter** node (no wiring from the Alarm node is needed).
  2. Select your **Alarm node** (recommended).
  3. Pick an **Output** preset:
     - stream/filter presets like `All Events`, `Siren`, `Zone Activity`, `Any Zone Open`, `Open Zones (...)`
     - transform presets like `HomeKit Security System (basic)`
     - formatter presets like `Cycle open zones (format)`
  4. Wire the Output Adapter to your target node (MQTT out, HomeKit, debug, ...).

  Notes:

  - This node has **no input pin**: it subscribes internally to the Alarm bus.
  - If **Alarm node** is not selected, it listens to **any** Alarm node (useful for debugging, not recommended in production).

  ### Built-in presets

  The **Output** dropdown contains built-in presets that can:

  - **Filter** by message group (former Alarm “outputs”): `All Events`, `Siren`, `Alarm Triggered`, `Arm/Disarm Updates`, `Zone Activity`, `Errors/Denied`, `Any Zone Open`, `Open Zones (Arming)`, `Open Zones (On Request)`, `Open Zones (Cycle)`.
  - **Transform** to an integration format (example: `HomeKit Security System (basic)`).
  - **Format** open-zones messages into a readable payload (example: `Cycle open zones (format)`).

  HomeKit note:

  - During `arming` (exit delay) HomeKit expects **TargetState** to change, while **CurrentState** usually stays on the previous state until arming completes.

  ### User preset

  Configure a preset (built-in or user-defined). A preset is JavaScript code executed as a function body:

  - Input: `msg`
  - Return: a message object, an array of messages, or `null/undefined` to drop.

  Example (map armed/disarmed to a topic):

  ```js
  if (!msg || typeof msg !== "object") return;
  if (msg.topic && msg.topic.endsWith("/event") && msg.event === "armed") {
    return { topic: "alarm/state", payload: "armed" };
  }
  if (msg.topic && msg.topic.endsWith("/event") && msg.event === "disarmed") {
    return { topic: "alarm/state", payload: "disarmed" };
  }
  ```
</script>
