<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Alarm Panel</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0b1020;
        --panel: #111936;
        --text: #e7eaf6;
        --muted: #a9b0d2;
        --border: #2a355f;
        --accent: #6ea8fe;
        --ok: #2fbf71;
        --warn: #ffcc66;
        --danger: #ff6b6b;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      @media (prefers-color-scheme: light) {
        :root {
          --bg: #f6f8ff;
          --panel: #ffffff;
          --text: #111827;
          --muted: #5b647a;
          --border: #d8deef;
          --accent: #2563eb;
        }
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--text);
        font-family: var(--sans);
      }

      body.embed header {
        display: none;
      }

      body.embed main {
        max-width: none;
        padding: 12px;
      }

      body.embed .grid {
        grid-template-columns: 1fr;
      }

      body.view-keypad .grid,
      body.view-zones .grid {
        grid-template-columns: 1fr;
      }

      body.view-keypad #zonesCard {
        display: none;
      }

      body.view-zones #keypadCard {
        display: none;
      }

      body.view-keypad #logCard,
      body.view-zones #logCard {
        display: none;
      }

      body.view-log .grid {
        display: none;
      }

      header {
        padding: 16px;
        border-bottom: 1px solid var(--border);
      }

      header h1 {
        margin: 0 0 6px 0;
        font-size: 18px;
      }

      header p {
        margin: 0;
        color: var(--muted);
        font-size: 13px;
      }

      main {
        max-width: 1200px;
        margin: 0 auto;
        padding: 16px;
        display: grid;
        gap: 12px;
      }

      .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      @media (max-width: 980px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }

      .card {
        border: 1px solid var(--border);
        background: var(--panel);
        border-radius: 10px;
        padding: 12px;
      }

      .card h2 {
        font-size: 14px;
        margin: 0 0 10px 0;
      }

      .row {
        display: grid;
        grid-template-columns: 140px 1fr;
        gap: 10px;
        align-items: center;
        margin: 8px 0;
      }

      .row label {
        font-size: 12px;
        color: var(--muted);
      }

      select,
      input[type="password"],
      input[type="text"] {
        width: 100%;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text);
        border-radius: 8px;
        padding: 8px 10px;
        box-sizing: border-box;
        font-family: var(--mono);
        font-size: 12px;
      }

      .buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
      }

      button {
        border: 1px solid var(--border);
        background: rgba(110, 168, 254, 0.12);
        color: var(--text);
        border-radius: 8px;
        padding: 8px 10px;
        cursor: pointer;
        font-size: 12px;
        transition: background-color 120ms ease, border-color 120ms ease, transform 80ms ease;
      }

      button.primary {
        border-color: rgba(110, 168, 254, 0.85);
        background: var(--accent);
        color: #fff;
      }

      button.danger {
        border-color: rgba(255, 107, 107, 0.55);
        background: rgba(255, 107, 107, 0.14);
      }

      button:hover {
        background: rgba(110, 168, 254, 0.18);
        border-color: rgba(110, 168, 254, 0.35);
      }

      button.primary:hover {
        filter: brightness(1.05);
      }

      button:active {
        transform: translateY(1px);
      }

      button.selected {
        border-color: rgba(110, 168, 254, 0.9);
        background: rgba(110, 168, 254, 0.28);
      }

      button.selected.ok {
        border-color: rgba(47, 191, 113, 0.65);
        background: rgba(47, 191, 113, 0.16);
      }

      button.selected.warn {
        border-color: rgba(255, 204, 102, 0.65);
        background: rgba(255, 204, 102, 0.14);
      }

      button.selected.danger {
        border-color: rgba(255, 107, 107, 0.65);
        background: rgba(255, 107, 107, 0.14);
      }

      button.node {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      button.node .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--border);
      }

      button.node.ok .dot {
        background: var(--ok);
      }
      button.node.warn .dot {
        background: var(--warn);
      }
      button.node.danger .dot {
        background: var(--danger);
      }

      .status {
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }

      .status .left {
        display: grid;
        gap: 2px;
      }

      .status .title {
        font-family: var(--mono);
        font-size: 13px;
      }

      .status .meta {
        color: var(--muted);
        font-size: 12px;
      }

      .status .meta .lines {
        display: grid;
        gap: 6px;
      }

      .status .meta .line {
        display: grid;
        grid-template-columns: 180px auto;
        gap: 10px;
        align-items: center;
      }

      .status .meta .line .name {
        font-family: var(--mono);
        font-size: 12px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .status .meta .line .details {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--muted);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .pill {
        font-family: var(--mono);
        font-size: 12px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
      }

      .pill.ok {
        border-color: rgba(47, 191, 113, 0.55);
        color: var(--ok);
      }
      .pill.warn {
        border-color: rgba(255, 204, 102, 0.55);
        color: var(--warn);
      }
      .pill.danger {
        border-color: rgba(255, 107, 107, 0.55);
        color: var(--danger);
      }

      .pill.small {
        padding: 4px 8px;
        font-size: 11px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        font-family: var(--mono);
        font-size: 12px;
      }

      th,
      td {
        border-bottom: 1px solid var(--border);
        padding: 8px 6px;
        text-align: left;
        vertical-align: top;
      }

      th {
        color: var(--muted);
        font-weight: 600;
      }

      .zone-open {
        color: var(--danger);
      }
      .zone-closed {
        color: var(--ok);
      }
      .zone-bypassed {
        color: var(--warn);
      }

      .kbd {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-top: 10px;
      }

      .kbd button {
        padding: 10px;
        font-family: var(--mono);
        font-size: 14px;
      }

      .hint {
        color: var(--muted);
        font-size: 12px;
        margin: 8px 0 0 0;
      }

      .log-details {
        color: var(--muted);
        font-size: 11px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Alarm Panel</h1>
      <p>View all zones and use the keypad to arm/disarm the Alarm System Ultimate node.</p>
    </header>

	    <main>
      <section class="card">
        <h2>Node</h2>
        <div class="row">
          <label>Alarm nodes</label>
          <div>
            <div class="buttons" id="nodeButtons"></div>
            <div class="hint" id="nodeHint"></div>
            <div class="hint" id="selectionHint"></div>
            <div class="buttons" style="margin-top:8px;">
              <button id="btnSelectAll" type="button">Select all</button>
            </div>
          </div>
        </div>
        <div id="nodeStatus" class="status" style="display: none">
          <div class="left">
            <div class="title" id="statusTitle"></div>
            <div class="meta" id="statusMeta"></div>
          </div>
          <div class="pill" id="statusPill"></div>
        </div>
      </section>

	      <div class="grid">
	        <section class="card" id="keypadCard" data-section="keypad">
	          <h2>Keypad</h2>
	          <div class="row">
	            <label for="code">Code</label>
	            <input id="code" type="password" autocomplete="one-time-code" placeholder="(optional)" />
	          </div>
          <div class="buttons">
            <button class="primary" id="btnArm">Arm</button>
            <button class="danger" id="btnDisarm">Disarm</button>
          </div>
          <div class="kbd" aria-label="Keypad">
            <button data-k="1">1</button>
            <button data-k="2">2</button>
            <button data-k="3">3</button>
            <button data-k="4">4</button>
            <button data-k="5">5</button>
            <button data-k="6">6</button>
            <button data-k="7">7</button>
            <button data-k="8">8</button>
            <button data-k="9">9</button>
            <button data-k="clear">Clear</button>
            <button data-k="0">0</button>
            <button data-k="back">Back</button>
          </div>
          <p class="hint">Commands are sent to the selected node using the Node-RED admin HTTP endpoint.</p>
          <p class="hint" id="cmdStatus" style="display: none"></p>
	        </section>

		        <section class="card" id="zonesCard" data-section="zones">
		          <h2>Zones</h2>
		          <div class="hint" id="zonesHint">Loading...</div>
              <div class="buttons" style="margin-top:8px;">
                <button id="btnZonesFilterOpen" type="button">OPEN</button>
                <button id="btnZonesFilterAll" type="button">ALL</button>
              </div>
		          <div style="overflow: auto; margin-top: 10px">
		            <table>
	              <thead>
	                <tr>
                  <th>Alarm</th>
                  <th>Zone</th>
                  <th>State</th>
                  <th>Type</th>
                  <th>Topic</th>
                </tr>
              </thead>
              <tbody id="zonesBody"></tbody>
            </table>
          </div>
        </section>
      </div>

      <section class="card" id="logCard" data-section="log">
        <h2>Log</h2>
        <div class="hint" id="logHint">Loading...</div>
        <div class="buttons" style="margin-top:8px;">
          <button id="btnLogFilterAll" type="button">ALL</button>
          <button id="btnLogFilterAlarm" type="button">ALARM</button>
          <button id="btnLogFilterArming" type="button">ARMING</button>
          <button id="btnLogFilterZones" type="button">ZONES</button>
          <button id="btnLogFilterErrors" type="button">ERRORS</button>
          <button id="btnLogDownload" type="button">Download JSON</button>
        </div>
        <div style="overflow:auto; margin-top:10px;">
          <table>
            <thead>
              <tr>
                <th>Alarm</th>
                <th>Time</th>
                <th>Event</th>
                <th>Details</th>
              </tr>
            </thead>
            <tbody id="logBody"></tbody>
          </table>
        </div>
      </section>
    </main>

    <script>
		      const els = {
		        nodeButtons: document.getElementById("nodeButtons"),
		        nodeHint: document.getElementById("nodeHint"),
	          selectionHint: document.getElementById("selectionHint"),
	          btnSelectAll: document.getElementById("btnSelectAll"),
		        nodeStatus: document.getElementById("nodeStatus"),
		        statusTitle: document.getElementById("statusTitle"),
		        statusMeta: document.getElementById("statusMeta"),
		        statusPill: document.getElementById("statusPill"),
		        zonesBody: document.getElementById("zonesBody"),
	        zonesHint: document.getElementById("zonesHint"),
	        btnZonesFilterOpen: document.getElementById("btnZonesFilterOpen"),
	        btnZonesFilterAll: document.getElementById("btnZonesFilterAll"),
	        logBody: document.getElementById("logBody"),
	        logHint: document.getElementById("logHint"),
	        btnLogFilterAll: document.getElementById("btnLogFilterAll"),
	        btnLogFilterAlarm: document.getElementById("btnLogFilterAlarm"),
	        btnLogFilterArming: document.getElementById("btnLogFilterArming"),
	        btnLogFilterZones: document.getElementById("btnLogFilterZones"),
	        btnLogFilterErrors: document.getElementById("btnLogFilterErrors"),
	        btnLogDownload: document.getElementById("btnLogDownload"),
	        code: document.getElementById("code"),
	        cmdStatus: document.getElementById("cmdStatus"),
	        btnArm: document.getElementById("btnArm"),
	        btnDisarm: document.getElementById("btnDisarm"),
	      };

      const params = new URLSearchParams(window.location.search);
      const preselectId = params.get("id") || "";
      const embedMode = params.get("embed") === "1" || params.get("embed") === "true";
      const view = (params.get("view") || "").toLowerCase();

      if (embedMode) {
        document.body.classList.add("embed");
      }

      if (view === "zones") {
        document.body.classList.add("view-zones");
      } else if (view === "keypad") {
        document.body.classList.add("view-keypad");
      } else if (view === "log") {
        document.body.classList.add("view-log");
      }

      const showLog = view !== "zones" && view !== "keypad";

      let nodesList = [];
      let selectedIds = new Set();
      let pollTimer = null;
      let nodeStateTimer = null;
      let nodeStateById = new Map();

      let logFilter = "all"; // all | alarm | arming | zones | errors
      let logsById = new Map(); // alarmId -> entries[]
      let logLastTsById = new Map(); // alarmId -> last ts

	      let audioCtx = null;
	      let armingBeepTimer = null;
	      let hasSeenState = false;
	      let lastMode = null;
	      let lastArmingActive = null;
	      let lastZonesSnapshot = [];
	      let zonesFilter = "open"; // "open" | "all"
	      let zonesFilterUserSelected = false;
	      let zonesFilterInitialized = false;

      function getAudioContext() {
        if (audioCtx) return audioCtx;
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return null;
        audioCtx = new Ctx();
        return audioCtx;
      }

      async function ensureAudioReady() {
        const ctx = getAudioContext();
        if (!ctx) return null;
        try {
          if (ctx.state === "suspended") {
            await ctx.resume();
          }
        } catch (err) {
          return null;
        }
        return ctx;
      }

      async function playBeep(freq, durationMs, volume, type) {
        const ctx = await ensureAudioReady();
        if (!ctx) return;

        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        osc.type = type || "sine";
        osc.frequency.setValueAtTime(Number(freq) || 800, now);

        const v = Math.max(0.0001, Math.min(Number(volume) || 0.08, 0.2));
        const dur = Math.max(0.01, (Number(durationMs) || 60) / 1000);

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(v, now + 0.004);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start(now);
        osc.stop(now + dur);

        osc.onended = () => {
          try {
            osc.disconnect();
            gain.disconnect();
          } catch (err) {}
        };
      }

      function stopArmingBeeps() {
        if (!armingBeepTimer) return;
        clearInterval(armingBeepTimer);
        armingBeepTimer = null;
      }

      function startArmingBeeps() {
        if (armingBeepTimer) return;
        playBeep(660, 50, 0.05, "sine");
        armingBeepTimer = setInterval(() => {
          playBeep(660, 50, 0.05, "sine");
        }, 800);
      }

      function playModeBeep(mode) {
        if (mode === "armed") {
          playBeep(880, 70, 0.085, "sine");
          setTimeout(() => playBeep(1175, 70, 0.085, "sine"), 110);
          return;
        }
        if (mode === "disarmed") {
          playBeep(587, 90, 0.085, "sine");
          setTimeout(() => playBeep(440, 110, 0.085, "sine"), 140);
        }
      }

      async function playKeyClick(kind) {
        const ctx = await ensureAudioReady();
        if (!ctx) return;

        const now = ctx.currentTime;
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        const freq =
          kind === "back" ? 520 : kind === "clear" ? 340 : kind === "action" ? 860 : 740;

        osc.type = "square";
        osc.frequency.setValueAtTime(freq, now);

        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.exponentialRampToValueAtTime(0.08, now + 0.002);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.03);

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start(now);
        osc.stop(now + 0.03);

        osc.onended = () => {
          try {
            osc.disconnect();
            gain.disconnect();
          } catch (err) {}
        };
      }

      function resetStateAudioTracking() {
        stopArmingBeeps();
        hasSeenState = false;
        lastMode = null;
        lastArmingActive = null;
      }

      function handleStateBeeps(state) {
        if (!state) return;

        const mode = typeof state.mode === "string" ? state.mode : null;
        const armingActive = Boolean(state.arming && state.arming.active);

        if (!hasSeenState) {
          hasSeenState = true;
          lastMode = mode;
          lastArmingActive = armingActive;
          if (armingActive) startArmingBeeps();
          return;
        }

        if (armingActive && !lastArmingActive) startArmingBeeps();
        if (!armingActive && lastArmingActive) stopArmingBeeps();

        if (mode && mode !== lastMode) {
          stopArmingBeeps();
          playModeBeep(mode);
        }

        lastMode = mode;
        lastArmingActive = armingActive;
      }

      function httpAdminRoot() {
        const base = window.location.pathname;
        const idx = base.indexOf("/alarm-ultimate/");
        if (idx >= 0) return base.slice(0, idx + 1);
        return "/";
      }

	      function apiUrl(path) {
	        const root = httpAdminRoot();
	        return root.endsWith("/") ? `${root}${path.replace(/^\//, "")}` : `${root}/${path.replace(/^\//, "")}`;
	      }

	      function setNodeHint(text) {
	        if (!els.nodeHint) return;
	        els.nodeHint.textContent = text || "";
	      }

	      function authHeaders() {
	        try {
	          const raw = localStorage.getItem("auth-tokens");
	          if (!raw) return {};
	          const tokens = JSON.parse(raw);
	          if (!tokens || !tokens.access_token) return {};
	          return { Authorization: `Bearer ${tokens.access_token}` };
	        } catch (err) {
	          return {};
	        }
	      }

	      function showCmdStatus(text, kind) {
	        els.cmdStatus.style.display = "";
	        els.cmdStatus.style.color = kind === "err" ? "var(--danger)" : kind === "ok" ? "var(--ok)" : "var(--muted)";
	        els.cmdStatus.textContent = text;
        setTimeout(() => {
          els.cmdStatus.style.display = "none";
        }, 2500);
      }

      function statusFromState(state) {
        if (!state) return { label: "Unknown", cls: "" };
        if (state.alarmActive) return { label: "ALARM", cls: "danger" };
        if (state.entry && state.entry.active) return { label: "ENTRY", cls: "warn" };
        if (state.arming && state.arming.active) return { label: "ARMING", cls: "warn" };
        if (state.mode === "armed") return { label: "ARMED", cls: "ok" };
        return { label: "DISARMED", cls: "" };
      }

      function lastEventSummary(state) {
        const log = state && Array.isArray(state.log) ? state.log : [];
        const last = log.length ? log[log.length - 1] : null;
        if (!last || typeof last !== "object") return "";
        const e = typeof last.event === "string" ? last.event : "";
        if (!e) return "";
        if (e === "arm_blocked") {
          const violations = Array.isArray(last.violations) ? last.violations : [];
          const names = violations
            .map((v) => (v && typeof v.name === "string" && v.name.trim() ? v.name.trim() : v && v.id ? String(v.id) : ""))
            .filter(Boolean);
          const shown = names.slice(0, 3).join(", ");
          const suffix = names.length > 3 ? "…" : "";
          return `arm_blocked${names.length ? ` (${shown}${suffix})` : ""}`;
        }
        if (e === "denied") {
          const a = last.action ? String(last.action) : "";
          return `denied${a ? ` (${a})` : ""}`;
        }
        if (e === "arming") {
          const s = Number.isFinite(Number(last.seconds)) ? Number(last.seconds) : null;
          return `arming${s !== null ? ` (${s}s)` : ""}`;
        }
        if (e === "entry_delay") {
          const s = Number.isFinite(Number(last.seconds)) ? Number(last.seconds) : null;
          return `entry_delay${s !== null ? ` (${s}s)` : ""}`;
        }
        if (e === "alarm") {
          const k = last.kind ? String(last.kind) : "";
          return `alarm${k ? ` (${k})` : ""}`;
        }
        return e;
      }

	      function armingErrorPill(state) {
	        const log = state && Array.isArray(state.log) ? state.log : [];
	        const last = log.length ? log[log.length - 1] : null;
	        const e = last && typeof last.event === "string" ? last.event : "";
	        if (e === "arm_blocked") {
	          return { cls: "warn", label: "ARM BLOCKED", details: lastEventSummary(state) };
	        }
	        if (e === "denied" && last && String(last.action || "") === "arm") {
	          return { cls: "danger", label: "ARM DENIED", details: lastEventSummary(state) };
	        }
	        return null;
	      }

	      function updateZonesFilterButtons() {
	        if (!els.btnZonesFilterOpen || !els.btnZonesFilterAll) return;
	        els.btnZonesFilterOpen.classList.toggle("selected", zonesFilter === "open");
	        els.btnZonesFilterAll.classList.toggle("selected", zonesFilter === "all");
	      }

	      function setZonesFilter(next, opts) {
	        const options = opts && typeof opts === "object" ? opts : {};
	        const user = options.user === true;
	        zonesFilter = String(next || "").toLowerCase() === "all" ? "all" : "open";
	        if (user) zonesFilterUserSelected = true;
	        updateZonesFilterButtons();
	        renderZones(lastZonesSnapshot);
	      }

	      function renderZones(zones) {
	        els.zonesBody.innerHTML = "";
	        const list = Array.isArray(zones) ? zones : [];
	        lastZonesSnapshot = list;
	        const filtered = zonesFilter === "open" ? list.filter((z) => z && z.open) : list;

	        if (list.length === 0) {
	          els.zonesHint.textContent = "No zones configured.";
	          return;
	        }
	        if (filtered.length === 0) {
	          els.zonesHint.textContent = "No OPEN zones.";
	          return;
	        }
	        if (zonesFilter === "open") {
	          els.zonesHint.textContent = `${filtered.length} OPEN zones (of ${list.length})`;
	        } else {
	          els.zonesHint.textContent = `${list.length} zones`;
	        }

	        for (const z of filtered) {
	          const tr = document.createElement("tr");
	          const title = z.name ? `${z.name}` : z.id;
	          const stateText = z.bypassed ? "BYPASSED" : z.open ? "OPEN" : "CLOSED";
	          const stateClass = z.bypassed ? "zone-bypassed" : z.open ? "zone-open" : "zone-closed";
	          const topic = z.topic || z.topicPattern || "";
	          const alarmLabel = z.__alarmName || z.__alarmId || "";

          tr.innerHTML = `
            <td>${escapeHtml(alarmLabel)}</td>
            <td>${escapeHtml(title)}</td>
            <td class="${stateClass}">${escapeHtml(stateText)}</td>
            <td>${escapeHtml(z.type || "")}</td>
            <td>${escapeHtml(topic)}</td>
          `;
          els.zonesBody.appendChild(tr);
        }
      }

      function escapeHtml(text) {
        return String(text || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      function pad2(n) {
        return String(Math.max(0, Math.trunc(Number(n) || 0))).padStart(2, "0");
      }

      function formatTs(ts) {
        const t = Number(ts) || 0;
        if (!t) return "";
        const d = new Date(t);
        return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(
          d.getMinutes(),
        )}:${pad2(d.getSeconds())}`;
      }

      function logGroupForEvent(e) {
        const evt = String(e || "").toLowerCase();
        if (evt === "alarm") return "alarm";
        if (evt === "error" || evt === "denied") return "errors";
        if (
          evt === "arming" ||
          evt === "armed" ||
          evt === "disarmed" ||
          evt === "entry_delay" ||
          evt === "arm_blocked" ||
          evt === "already_armed" ||
          evt === "reset" ||
          evt === "siren_on" ||
          evt === "siren_off"
        )
          return "arming";
        if (
          evt === "bypassed" ||
          evt === "unbypassed" ||
          evt === "chime" ||
          evt === "zone_open" ||
          evt === "zone_close" ||
          evt === "zone_ignored_exit" ||
          evt === "zone_bypassed_trigger" ||
          evt === "zone_restore"
        )
          return "zones";
        return "all";
      }

      function eventPillClass(evt) {
        const g = logGroupForEvent(evt);
        if (g === "alarm") return "danger";
        if (g === "errors") return "danger";
        if (g === "arming") return "warn";
        if (g === "zones") return "";
        return "";
      }

      function eventDetails(entry) {
        const e = entry && entry.event ? String(entry.event) : "";

        if (e === "alarm") {
          const k = entry && entry.kind ? String(entry.kind) : "";
          const z = entry && entry.zone && typeof entry.zone === "object" ? entry.zone : null;
          const zn = z && (z.name || z.id) ? String(z.name || z.id) : "";
          const silent = entry && entry.silent === true ? "silent" : "";
          return [k ? `kind=${k}` : "", zn ? `zone=${zn}` : "", silent].filter(Boolean).join(" • ");
        }

        if (e === "denied") {
          const a = entry && entry.action ? String(entry.action) : "";
          const t = entry && entry.target ? String(entry.target) : "";
          return [a ? `action=${a}` : "", t ? `target=${t}` : ""].filter(Boolean).join(" • ");
        }

        if (e === "error") {
          const err = entry && entry.error ? String(entry.error) : "";
          const z = entry && entry.zone ? String(entry.zone) : "";
          return [err ? `error=${err}` : "", z ? `zone=${z}` : ""].filter(Boolean).join(" • ");
        }

        if (e === "arm_blocked") {
          const v = Array.isArray(entry && entry.violations) ? entry.violations : [];
          if (!v.length) return "violations";
          const top = v
            .slice(0, 3)
            .map((x) => (x && typeof x === "object" ? x.id || x.name || x.zone || "" : ""))
            .filter(Boolean)
            .join(", ");
          return `violations=${v.length}${top ? ` (${top}${v.length > 3 ? ", …" : ""})` : ""}`;
        }

        if (e === "arming" || e === "entry_delay") {
          const s = Number.isFinite(Number(entry && entry.seconds)) ? Number(entry.seconds) : null;
          const z = entry && entry.zone && typeof entry.zone === "object" ? entry.zone : null;
          const zn = z && (z.name || z.id) ? String(z.name || z.id) : "";
          return [s !== null ? `seconds=${s}` : "", zn ? `zone=${zn}` : ""].filter(Boolean).join(" • ");
        }

        if (e === "armed" || e === "disarmed") {
          const r = entry && entry.reason ? String(entry.reason) : "";
          const d = entry && entry.duress === true ? "duress" : "";
          return [r ? `reason=${r}` : "", d].filter(Boolean).join(" • ");
        }

        if (e === "siren_on" || e === "siren_off") {
          const r = entry && entry.reason ? String(entry.reason) : "";
          return r ? `reason=${r}` : "";
        }

        if (
          e === "bypassed" ||
          e === "unbypassed" ||
          e === "chime" ||
          e === "zone_open" ||
          e === "zone_close" ||
          e === "zone_ignored_exit" ||
          e === "zone_bypassed_trigger" ||
          e === "zone_restore"
        ) {
          const z = entry && entry.zone && typeof entry.zone === "object" ? entry.zone : null;
          const zn = z && (z.name || z.id) ? String(z.name || z.id) : "";
          const b = entry && entry.bypassed === true ? "bypassed" : "";
          return [zn ? `zone=${zn}` : "", b].filter(Boolean).join(" • ");
        }

        try {
          const copy = { ...(entry || {}) };
          delete copy.ts;
          delete copy.event;
          const keys = Object.keys(copy);
          if (!keys.length) return "";
          const txt = JSON.stringify(copy);
          return txt.length > 220 ? `${txt.slice(0, 220)}…` : txt;
        } catch (_err) {
          return "";
        }
      }

      function updateLogFilterButtons() {
        const map = [
          ["all", els.btnLogFilterAll],
          ["alarm", els.btnLogFilterAlarm],
          ["arming", els.btnLogFilterArming],
          ["zones", els.btnLogFilterZones],
          ["errors", els.btnLogFilterErrors],
        ];
        map.forEach(([key, el]) => {
          if (!el) return;
          el.classList.toggle("selected", logFilter === key);
        });
      }

      function setLogFilter(next) {
        const v = String(next || "").toLowerCase();
        logFilter = ["all", "alarm", "arming", "zones", "errors"].includes(v) ? v : "all";
        updateLogFilterButtons();
        renderLogs();
      }

      function resetLogTracking() {
        logsById = new Map();
        logLastTsById = new Map();
      }

      async function fetchLogForNode(nodeId, since) {
        const qs = new URLSearchParams();
        qs.set("limit", "200");
        if (Number.isFinite(Number(since)) && Number(since) > 0) {
          qs.set("since", String(Number(since)));
        }
        const res = await fetch(apiUrl(`/alarm-ultimate/alarm/${encodeURIComponent(nodeId)}/log?${qs.toString()}`), {
          credentials: "same-origin",
          headers: { ...authHeaders() },
        });
        if (!res.ok) throw new Error(`Unable to load log (${res.status})`);
        return res.json();
      }

      async function loadLogs(okStates) {
        if (!showLog) return;
        if (!els.logBody || !els.logHint) return;
        const ids = Array.from(selectedIds);
        if (!ids.length) return;

        const nameById = new Map(
          (Array.isArray(okStates) ? okStates : []).map((x) => [x.id, (x.data && x.data.name) || x.id]),
        );

        const results = await Promise.allSettled(
          ids.map(async (id) => {
            const since = logLastTsById.has(id) ? logLastTsById.get(id) : null;
            const data = await fetchLogForNode(id, since);
            return { id, data };
          }),
        );

        for (const r of results) {
          if (r.status !== "fulfilled") continue;
          const id = r.value.id;
          const payload = r.value.data && typeof r.value.data === "object" ? r.value.data : {};
          const entries = Array.isArray(payload.log) ? payload.log : [];

          const prev = logsById.get(id) || [];
          const next = logLastTsById.has(id) ? prev.concat(entries) : entries;
          logsById.set(id, next);

          const maxTs = next.reduce((m, e) => Math.max(m, Number(e && e.ts) || 0), 0);
          logLastTsById.set(id, maxTs);
        }

        renderLogs(nameById);
      }

      function renderLogs(nameById) {
        if (!els.logBody || !els.logHint) return;
        const ids = Array.from(selectedIds);
        const nameMap = nameById instanceof Map ? nameById : new Map(ids.map((id) => [id, id]));

        const all = [];
        ids.forEach((id) => {
          const alarmName = nameMap.get(id) || id;
          const list = logsById.get(id) || [];
          list.forEach((e) => all.push({ ...(e || {}), __alarmId: id, __alarmName: alarmName }));
        });

        const filtered =
          logFilter === "all" ? all : all.filter((e) => logGroupForEvent(e && e.event) === logFilter);

        filtered.sort((a, b) => (Number(b.ts) || 0) - (Number(a.ts) || 0));
        const show = filtered.slice(0, 200);

        if (!show.length) {
          els.logHint.textContent = "No log entries yet.";
          els.logBody.innerHTML = "";
          return;
        }

        els.logHint.textContent = `Showing ${show.length} entr${show.length === 1 ? "y" : "ies"}${
          logFilter !== "all" ? ` (${logFilter})` : ""
        }.`;
        els.logBody.innerHTML = "";

        for (const entry of show) {
          const tr = document.createElement("tr");
          const alarmLabel = entry.__alarmName || entry.__alarmId || "";
          const evt = entry && entry.event ? String(entry.event) : "";
          const cls = eventPillClass(evt);
          const details = eventDetails(entry);

          tr.innerHTML = `
            <td>${escapeHtml(alarmLabel)}</td>
            <td>${escapeHtml(formatTs(entry.ts))}</td>
            <td><span class="pill small ${cls}">${escapeHtml(evt)}</span></td>
            <td class="log-details">${escapeHtml(details)}</td>
          `;
          els.logBody.appendChild(tr);
        }
      }

        function normalizePreselectIds(raw) {
          const v = String(raw || "").trim();
          if (!v) return [];
          if (v.includes(",")) {
            return v
              .split(",")
              .map((s) => s.trim())
              .filter(Boolean);
          }
          return [v];
        }

        function persistSelectedIds() {
          try {
            localStorage.setItem("alarm-ultimate-panel:selectedIds", JSON.stringify(Array.from(selectedIds)));
          } catch (_err) {}
        }

	        function restoreSelectedIds() {
	          const idsFromUrl = normalizePreselectIds(preselectId);
	          if (idsFromUrl.length) return idsFromUrl;
	          try {
	            const raw = localStorage.getItem("alarm-ultimate-panel:selectedIds");
	            const parsed = JSON.parse(raw);
	            if (Array.isArray(parsed)) return parsed.map(String).filter(Boolean);
	          } catch (_err) {}
	          return [];
	        }

	        function updateSelectAllVisibility() {
	          if (!els.btnSelectAll) return;
	          const container = els.btnSelectAll.closest(".buttons") || els.btnSelectAll;
	          container.style.display = nodesList.length > 1 ? "" : "none";
	        }

	        function statusFromStateSafe(state) {
	          const st = statusFromState(state);
	          return st && typeof st === "object" ? st : { label: "Unknown", cls: "" };
	        }

        function updateSelectionHint() {
          const count = selectedIds.size;
          if (!els.selectionHint) return;
          if (count === 0) {
            els.selectionHint.textContent = "Select at least one Alarm node.";
            return;
          }
          els.selectionHint.innerHTML = `Selected: <span class="pill small">${count}</span> (click buttons to add/remove)`;
        }

	        function setSelectedIds(next) {
	          const ids = Array.isArray(next) ? next.map(String).filter(Boolean) : [];
	          selectedIds = new Set(ids);
	          // enforce non-empty selection when possible
	          if (selectedIds.size === 0 && nodesList[0]) {
	            selectedIds.add(nodesList[0].id);
	          }
	          persistSelectedIds();
	          resetStateAudioTracking();
	          resetLogTracking();
	          updateSelectionHint();
	          renderNodeButtons();
	          loadState().catch(() => {});
	        }

        function selectAll() {
          if (!nodesList.length) return;
          setSelectedIds(nodesList.map((n) => n.id));
        }

        function toggleSelectedId(id) {
          const key = String(id || "").trim();
          if (!key) return;
          const next = new Set(selectedIds);
          if (next.has(key)) {
            if (next.size === 1) return; // never allow empty
            next.delete(key);
          } else {
            next.add(key);
          }
          setSelectedIds(Array.from(next));
        }

	        function renderNodeButtons() {
	          if (!els.nodeButtons) return;
	          updateSelectAllVisibility();
	          els.nodeButtons.innerHTML = "";
	          if (!nodesList.length) return;

	          nodesList.forEach((n) => {
	            const state = nodeStateById.get(n.id);
            const st = statusFromStateSafe(state);
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = `node ${st.cls || ""} ${selectedIds.has(n.id) ? `selected ${st.cls || ""}` : ""}`.trim();
            btn.dataset.id = n.id;
            const name = n.name ? n.name : n.id;
            btn.innerHTML = `<span class="dot"></span><span>${escapeHtml(name)}</span>`;
            btn.addEventListener("click", () => toggleSelectedId(n.id));
            els.nodeButtons.appendChild(btn);
          });
        }

		      async function loadNodes() {
		        const res = await fetch(apiUrl("/alarm-ultimate/alarm/nodes"), {
		          credentials: "same-origin",
		          headers: { ...authHeaders() },
		        });
		        if (!res.ok) throw new Error(`Unable to load nodes (${res.status})`);
		        const data = await res.json();
		        nodesList = Array.isArray(data.nodes) ? data.nodes : [];
	          updateSelectAllVisibility();
	          if (!nodesList.length) {
		          els.zonesHint.textContent = "No Alarm nodes found.";
		          setNodeHint("No Alarm nodes found. Deploy your flow and refresh.");
	            renderNodeButtons();
	            updateSelectionHint();
          } else {
	          setNodeHint("");
            const restored = restoreSelectedIds().filter((id) => nodesList.some((n) => n.id === id));
            setSelectedIds(restored.length ? restored : [nodesList[0].id]);
	        }
	      }

        async function fetchStateForNode(nodeId) {
          const res = await fetch(apiUrl(`/alarm-ultimate/alarm/${encodeURIComponent(nodeId)}/state`), {
            credentials: "same-origin",
            headers: { ...authHeaders() },
          });
          if (!res.ok) throw new Error(`Unable to load state (${res.status})`);
          return res.json();
        }

        async function loadNodeStatesForButtons() {
          if (!nodesList.length) return;
          const ids = nodesList.map((n) => n.id);
          const results = await Promise.allSettled(ids.map((id) => fetchStateForNode(id)));
          for (let i = 0; i < results.length; i += 1) {
            const id = ids[i];
            const r = results[i];
            if (r.status === "fulfilled") {
              nodeStateById.set(id, r.value && r.value.state ? r.value.state : null);
            }
          }
          renderNodeButtons();
        }

	        async function loadState() {
	          const ids = Array.from(selectedIds);
	          if (!ids.length) return;

          const results = await Promise.allSettled(ids.map((id) => fetchStateForNode(id)));
          const okStates = [];
          for (let i = 0; i < results.length; i += 1) {
            const id = ids[i];
            const r = results[i];
            if (r.status === "fulfilled") {
              okStates.push({ id, data: r.value });
              nodeStateById.set(id, r.value && r.value.state ? r.value.state : null);
            }
          }

          renderNodeButtons();
          updateSelectionHint();

          if (okStates.length === 0) {
            els.nodeStatus.style.display = "none";
            els.zonesHint.textContent = "Unable to load selected alarm state.";
            return;
          }

          // Combine status and zones.
          const zones = [];
          okStates.forEach(({ id, data }) => {
            const alarmName = data && data.name ? data.name : id;
            const list = Array.isArray(data && data.zones) ? data.zones : [];
            list.forEach((z) => zones.push({ ...z, __alarmId: id, __alarmName: alarmName }));
          });

          zones.sort((a, b) => {
            const an = String(a.__alarmName || "").localeCompare(String(b.__alarmName || ""));
            if (an !== 0) return an;
            return String(a.name || a.id || "").localeCompare(String(b.name || b.id || ""));
          });

          const multiple = okStates.length > 1;
          if (multiple) {
            stopArmingBeeps();
          }

          els.nodeStatus.style.display = "";
          els.statusTitle.textContent = multiple
            ? `Selected alarms (${okStates.length})`
            : okStates[0].data && okStates[0].data.name
              ? okStates[0].data.name
              : okStates[0].id;

          if (multiple) {
            const lines = okStates
              .map(({ id, data }) => {
                const state = data && data.state ? data.state : null;
                const st = statusFromStateSafe(state);
                const name = data && data.name ? data.name : id;
                const openCount = Array.isArray(data && data.zones)
                  ? data.zones.filter((z) => z && z.open && !z.bypassed).length
                  : 0;
                const lastEvt = lastEventSummary(state);
                const armErr = armingErrorPill(state);
                const details = [
                  `state=${st.label}`,
                  openCount ? `open=${openCount}` : "",
                  lastEvt ? `last=${lastEvt}` : "",
                ]
                  .filter(Boolean)
                  .join(" • ");

                return `
                  <div class="line">
                    <div class="name">${escapeHtml(name)}</div>
                    <div class="details">
                      <span class="pill small ${st.cls || ""}">${escapeHtml(st.label)}</span>
                      ${
                        armErr
                          ? ` <span class="pill small ${armErr.cls}">${escapeHtml(armErr.label)}</span>`
                          : ""
                      }
                      ${details ? `&nbsp;${escapeHtml(details)}` : ""}
                    </div>
                  </div>
                `;
              })
              .join("");

            els.statusMeta.innerHTML = `<div class="lines">${lines}</div>`;
            els.statusPill.textContent = "MULTI";
            els.statusPill.className = "pill warn";
          } else {
            const state = okStates[0].data && okStates[0].data.state ? okStates[0].data.state : null;
            const st = statusFromStateSafe(state);
            const openCount = zones.filter((z) => z.open && !z.bypassed).length;
            const lastEvt = lastEventSummary(state);
            const armErr = armingErrorPill(state);
            const meta = [`${st.label}`, openCount ? `open=${openCount}` : "", lastEvt ? `last=${lastEvt}` : ""]
              .filter(Boolean)
              .join(" • ");
            els.statusMeta.textContent = meta;
            els.statusPill.textContent = st.label;
            els.statusPill.className = `pill ${st.cls}`;
            if (armErr && els.statusPill) {
              els.statusPill.textContent = armErr.label;
              els.statusPill.className = `pill ${armErr.cls}`;
            }
	          }

	          if (!zonesFilterInitialized && !zonesFilterUserSelected) {
	            zonesFilter = zones.some((z) => z && z.open) ? "open" : "all";
	            zonesFilterInitialized = true;
	            updateZonesFilterButtons();
	          }
		          renderZones(zones);
		          if (!multiple) {
		            handleStateBeeps(okStates[0].data && okStates[0].data.state);
		          }
              if (showLog) {
                await loadLogs(okStates);
              }
		        }

      function startPolling() {
        if (pollTimer) clearInterval(pollTimer);
        pollTimer = setInterval(() => {
          loadState().catch((err) => {
            els.zonesHint.textContent = err.message;
          });
        }, 1000);
      }

      function startNodeButtonPolling() {
        if (nodeStateTimer) clearInterval(nodeStateTimer);
        nodeStateTimer = setInterval(() => {
          loadNodeStatesForButtons().catch(() => {});
        }, 2500);
      }

        function extractResultState(json) {
          const root = json && typeof json === "object" ? json : null;
          const result = root && root.result && typeof root.result === "object" ? root.result : null;
          return result && result.state ? result.state : null;
        }

        function extractResultName(json, fallbackId) {
          const root = json && typeof json === "object" ? json : null;
          const result = root && root.result && typeof root.result === "object" ? root.result : null;
          return (result && result.name) || fallbackId || "";
        }

        function isArmSuccess(state) {
          if (!state) return false;
          if (state.mode === "armed") return true;
          return Boolean(state.arming && state.arming.active);
        }

        function isDisarmSuccess(state) {
          if (!state) return false;
          return state.mode === "disarmed";
        }

	      async function sendCommand(payload) {
	        const ids = Array.from(selectedIds);
	        if (!ids.length) return;
          const results = await Promise.allSettled(
            ids.map(async (id) => {
              const res = await fetch(apiUrl(`/alarm-ultimate/alarm/${encodeURIComponent(id)}/command`), {
                method: "POST",
                headers: { "content-type": "application/json", ...authHeaders() },
                body: JSON.stringify(payload),
                credentials: "same-origin",
              });
              if (!res.ok) {
                const text = await res.text();
                throw new Error(`(${id}) ${res.status}: ${text}`);
              }
              const json = await res.json().catch(() => null);
              const state = extractResultState(json);
              if (state) {
                nodeStateById.set(id, state);
              }
              return {
                id,
                name: extractResultName(json, id),
                state,
              };
            }),
          );
          const ok = results.filter((r) => r.status === "fulfilled").map((r) => r.value);
          const err = results
            .filter((r) => r.status === "rejected")
            .map((r) => (r.reason && r.reason.message ? r.reason.message : String(r.reason)));

          // Heuristic feedback: HTTP 200 doesn't mean the Alarm accepted the command.
          const cmd = payload && typeof payload.command === "string" ? payload.command : "";
          const check = cmd === "disarm" ? isDisarmSuccess : cmd === "arm" ? isArmSuccess : null;
          const okApplied = check ? ok.filter((r) => check(r && r.state)).map((r) => r.name || r.id) : [];
          const maybeRejected = check ? ok.filter((r) => !check(r && r.state)).map((r) => r.name || r.id) : [];

          renderNodeButtons();

          if (err.length) {
            throw new Error(`Sent to ${ok.length}/${ids.length}. ${err[0]}`);
          }
          if (check && maybeRejected.length) {
            showCmdStatus(
              `${cmd} sent to ${ids.length}. Applied: ${okApplied.length}/${ids.length}. Not applied: ${maybeRejected.slice(0, 3).join(", ")}${maybeRejected.length > 3 ? "…" : ""}`,
              "warn",
            );
          }
      }

      function codeValue() {
        const v = String(els.code.value || "").trim();
        return v.length ? v : undefined;
      }

	      // No select: buttons manage selection.
	      if (els.btnSelectAll) {
	        els.btnSelectAll.addEventListener("click", () => selectAll());
	      }
	      if (els.btnZonesFilterOpen) {
	        els.btnZonesFilterOpen.addEventListener("click", () => setZonesFilter("open", { user: true }));
	      }
		      if (els.btnZonesFilterAll) {
		        els.btnZonesFilterAll.addEventListener("click", () => setZonesFilter("all", { user: true }));
		      }
		      if (els.btnLogFilterAll) {
		        els.btnLogFilterAll.addEventListener("click", () => setLogFilter("all"));
		      }
		      if (els.btnLogFilterAlarm) {
		        els.btnLogFilterAlarm.addEventListener("click", () => setLogFilter("alarm"));
		      }
		      if (els.btnLogFilterArming) {
		        els.btnLogFilterArming.addEventListener("click", () => setLogFilter("arming"));
		      }
		      if (els.btnLogFilterZones) {
		        els.btnLogFilterZones.addEventListener("click", () => setLogFilter("zones"));
		      }
		      if (els.btnLogFilterErrors) {
		        els.btnLogFilterErrors.addEventListener("click", () => setLogFilter("errors"));
		      }
		      if (els.btnLogDownload) {
		        els.btnLogDownload.addEventListener("click", () => {
		          const ids = Array.from(selectedIds);
		          const out = [];
		          ids.forEach((id) => {
		            const alarmName = nodesList.find((n) => n && n.id === id)?.name || id;
		            const list = logsById.get(id) || [];
		            list.forEach((e) => out.push({ ...(e || {}), alarmId: id, alarmName }));
		          });
		          out.sort((a, b) => (Number(a.ts) || 0) - (Number(b.ts) || 0));
		          const blob = new Blob([JSON.stringify(out, null, 2)], { type: "application/json" });
		          const a = document.createElement("a");
		          a.href = URL.createObjectURL(blob);
		          a.download = `alarm-log-${new Date().toISOString().replace(/[:.]/g, "-")}.json`;
		          document.body.appendChild(a);
		          a.click();
		          setTimeout(() => {
		            try {
		              URL.revokeObjectURL(a.href);
		              a.remove();
		            } catch (_err) {}
		          }, 0);
		        });
		      }

		      els.btnArm.addEventListener("click", async () => {
		        playKeyClick("action");
		        try {
	          await sendCommand({ command: "arm", code: codeValue() });
          if (els.cmdStatus.style.display === "none") {
            showCmdStatus(`Arm sent to ${selectedIds.size} node(s).`, "ok");
          }
        } catch (err) {
          showCmdStatus(err.message, "err");
        }
      });
      els.btnDisarm.addEventListener("click", async () => {
        playKeyClick("action");
        try {
          await sendCommand({ command: "disarm", code: codeValue() });
          if (els.cmdStatus.style.display === "none") {
            showCmdStatus(`Disarm sent to ${selectedIds.size} node(s).`, "ok");
          }
        } catch (err) {
          showCmdStatus(err.message, "err");
        }
      });

      document.querySelector(".kbd").addEventListener("click", (e) => {
        const btn = e.target && e.target.closest("button");
        if (!btn) return;
        const k = btn.getAttribute("data-k");
        if (!k) return;
        if (k === "clear") {
          playKeyClick("clear");
          els.code.value = "";
          return;
        }
        if (k === "back") {
          playKeyClick("back");
          els.code.value = String(els.code.value || "").slice(0, -1);
          return;
        }
        playKeyClick("key");
        els.code.value = `${els.code.value || ""}${k}`;
      });

      els.code.addEventListener("keydown", (e) => {
        if (e.key === "Backspace") playKeyClick("back");
        else if (e.key === "Escape" || e.key === "Delete") playKeyClick("clear");
        else if (/^\d$/.test(e.key)) playKeyClick("key");
      });

		      (async function init() {
		        try {
		          setNodeHint(`API root: ${httpAdminRoot()}`);
		          updateLogFilterButtons();
		          if (showLog && els.logHint) {
		            els.logHint.textContent = "Loading...";
		          }
		          await loadNodes();
	            await loadNodeStatesForButtons().catch(() => {});
		          await loadState();
		          startPolling();
	            startNodeButtonPolling();
	        } catch (err) {
	          setNodeHint(err.message);
	          els.zonesHint.textContent = err.message;
	        }
	      })();
	    </script>
	  </body>
	</html>
