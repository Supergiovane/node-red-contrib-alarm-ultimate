<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Alarm JSON Mapper (Node-RED)</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #0b1020;
      --panel: #111936;
      --text: #e7eaf6;
      --muted: #a9b0d2;
      --border: #2a355f;
      --accent: #6ea8fe;
      --ok: #2fbf71;
      --warn: #ffcc66;
      --danger: #ff6b6b;
      --mono:
        ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      --sans:
        system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,
        "Apple Color Emoji", "Segoe UI Emoji";
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f8ff;
        --panel: #ffffff;
        --text: #111827;
        --muted: #5b647a;
        --border: #d8deef;
        --accent: #2563eb;
      }
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: var(--sans);
      line-height: 1.4;
    }

    header {
      padding: 18px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg,
          rgba(110, 168, 254, 0.12),
          rgba(0, 0, 0, 0));
    }

    header h1 {
      font-size: 18px;
      margin: 0 0 6px 0;
    }

    header p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
    }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 16px;
      display: grid;
      gap: 12px;
    }

    .grid {
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      gap: 12px;
    }

    @media (max-width: 980px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .card {
      border: 1px solid var(--border);
      background: var(--panel);
      border-radius: 10px;
      padding: 12px;
    }

    .card h2 {
      font-size: 14px;
      margin: 0 0 10px 0;
    }

    .row {
      display: grid;
      grid-template-columns: 160px 1fr;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
    }

    .row label {
      font-size: 12px;
      color: var(--muted);
    }

    textarea,
    select,
    input[type="text"],
    input[type="number"] {
      width: 100%;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      box-sizing: border-box;
      font-family: var(--mono);
      font-size: 12px;
    }

    textarea {
      min-height: 240px;
      resize: vertical;
    }

    input[type="number"] {
      font-variant-numeric: tabular-nums;
    }

    .zone-sup {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 8px;
      align-items: center;
    }

    .zone-sup label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
      user-select: none;
      white-space: nowrap;
    }

    .zone-sup .sup-time {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .zone-sup .sup-time span {
      font-size: 12px;
      color: var(--muted);
      font-family: var(--mono);
    }

    .zone-sup input[type="checkbox"] {
      width: auto;
      margin: 0;
    }

    .zone-sup input[type="number"] {
      min-width: 80px;
    }

    .buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }

    button {
      border: 1px solid var(--border);
      background: rgba(110, 168, 254, 0.12);
      color: var(--text);
      border-radius: 8px;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 12px;
      transition: background-color 120ms ease, border-color 120ms ease, transform 80ms ease;
    }

    button.primary {
      border-color: rgba(110, 168, 254, 0.85);
      background: var(--accent);
      color: #ffffff;
    }

    button:hover {
      background: rgba(110, 168, 254, 0.18);
      border-color: rgba(110, 168, 254, 0.35);
    }

    button.primary:hover {
      filter: brightness(1.05);
    }

    button:active {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      margin: 6px 0 0 0;
    }

    .status {
      font-family: var(--mono);
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      margin-top: 10px;
    }

    .status.ok {
      border-color: rgba(47, 191, 113, 0.55);
      color: var(--ok);
    }

    .status.warn {
      border-color: rgba(255, 204, 102, 0.55);
      color: var(--warn);
    }

    .status.err {
      border-color: rgba(255, 107, 107, 0.55);
      color: var(--danger);
    }

    pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: var(--mono);
      font-size: 12px;
    }

    .mono {
      font-family: var(--mono);
    }

    .two {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    @media (max-width: 980px) {
      .two {
        grid-template-columns: 1fr;
      }
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-family: var(--mono);
      font-size: 12px;
    }

    th,
    td {
      border-bottom: 1px solid var(--border);
      padding: 8px 6px;
      text-align: left;
      vertical-align: top;
    }

    th {
      color: var(--muted);
      font-weight: 600;
      font-size: 11px;
      letter-spacing: 0.2px;
    }

    td input[type="text"],
    td input[type="number"],
    td select {
      width: 100%;
      padding: 6px 8px;
      font-size: 12px;
    }

    .btn-danger {
      border-color: rgba(255, 107, 107, 0.6);
      background: rgba(255, 107, 107, 0.12);
      color: var(--text);
    }

    .btn-danger:hover {
      background: rgba(255, 107, 107, 0.18);
      border-color: rgba(255, 107, 107, 0.7);
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 11px;
      color: var(--muted);
      font-family: var(--mono);
    }

    .pill.ok {
      border-color: rgba(47, 191, 113, 0.55);
      color: var(--ok);
    }

    .pill.warn {
      border-color: rgba(255, 204, 102, 0.55);
      color: var(--warn);
    }

    .pill.err {
      border-color: rgba(255, 107, 107, 0.55);
      color: var(--danger);
    }

    .disabled {
      opacity: 0.55;
      pointer-events: none;
      filter: grayscale(0.15);
    }
  </style>
</head>

<body>
  <header>
    <h1>Alarm JSON Mapper</h1>
    <p>
      Paste a sample incoming message (e.g. KNX Ultimate) and map its fields
      to what the Alarm node needs (topic/value), or paste an ETS Group
      Addresses export (TSV) to generate zones in batch.
    </p>
  </header>

  <main>
    <section class="card">
      <h2>Zones</h2>
      <div class="buttons">
        <button id="btn-zone-add">Add zone</button>
        <button class="primary" id="btn-wizard-toggle">Import zones wizard</button>
      </div>
      <p id="zone-context" class="hint"></p>
      <p class="hint" style="margin-top:4px;">
        Connection: <span id="zone-connection" class="pill">Not connected</span>
      </p>
      <p id="zone-autosave" class="hint" style="display:none;"></p>
      <div style="overflow:auto; border:1px solid var(--border); border-radius:10px;">
	        <table>
	          <thead>
	            <tr>
	              <th>Topic</th>
	              <th style="width: 220px;">Name</th>
	              <th style="width: 140px;">Kind</th>
	              <th style="width: 260px;">Supervision</th>
	              <th style="width: 90px;">Actions</th>
            </tr>
          </thead>
          <tbody id="zone-table-body"></tbody>
        </table>
      </div>
      <div id="zone-list-status" class="status warn" style="display:none; margin-top:10px;"></div>
    </section>

    <div id="wizard" style="display:none;">
      <div class="grid">
        <section class="card" id="wizard-step1">
          <h2>Step 1 — Paste data</h2>
          <textarea id="input" spellcheck="false"
            placeholder="Paste JSON here (message/HA export) or TSV (ETS export).&#10;&#10;Tip: this tool also accepts JS-style objects with unquoted keys and // comments."></textarea>
          <div class="buttons">
            <select id="sampleKind" style="max-width: 260px;">
              <option value="">(optional) load a sample…</option>
              <option value="knx">JSON message (KNX)</option>
              <option value="ets">ETS export (TSV)</option>
              <option value="ha">Home Assistant states (JSON)</option>
              <option value="ha_registry">Home Assistant entity registry (JSON)</option>
            </select>
            <button id="btn-load-sample">Load sample</button>
            <button id="btn-clear">Clear</button>
            <button class="primary" id="btn-parse">Parse / detect</button>
          </div>
          <p class="hint">
            Parse detects the format and unlocks the next step.
          </p>
          <div id="parse-status" class="status warn" style="display: none"></div>
        </section>

        <section class="card disabled" id="wizard-step2">
          <h2>Step 2 — Map & generate</h2>
          <div id="ets-hint" class="status ok" style="display: none"></div>
          <div id="ha-hint" class="status ok" style="display: none"></div>
          <div id="ets-mapping" style="display: none">
            <div class="row">
              <label for="etsAddressFilter">ETS address filter</label>
              <input type="text" id="etsAddressFilter"
                placeholder="Examples: 0/0/*  •  0/1/??  •  */7/*  (comma or newline separated)" />
            </div>
            <div class="row">
              <label for="etsNameFilter">ETS name filter</label>
              <input type="text" id="etsNameFilter"
                placeholder='Optional. Examples: Front door • *garage* (supports * and ?)' />
            </div>
            <p class="hint">
              Address patterns are matched against the ETS <span class="mono">Address</span> column (e.g.
              <span class="mono">0/0/1</span>). Name filter is matched against <span class="mono">Description</span>,
              fallback to <span class="mono">Group name</span>.
            </p>
          </div>
          <div id="ha-mapping" style="display: none">
            <div class="row">
              <label for="haEntityFilter">HA entity filter</label>
              <input type="text" id="haEntityFilter"
                placeholder="Examples: binary_sensor.*door*  •  *_pir  •  switch.*  (comma or newline separated)" />
            </div>
            <div class="row">
              <label for="haNameFilter">HA name filter</label>
              <input type="text" id="haNameFilter"
                placeholder='Optional. Examples: Front door • *garage* (supports * and ?)' />
            </div>
            <div class="row">
              <label for="haDomains">HA domains</label>
              <input type="text" id="haDomains"
                placeholder="Optional. Example: binary_sensor,input_boolean,switch (default: boolean-like domains)" />
            </div>
            <div class="row">
              <label for="haIncludeDisabled">Include disabled</label>
              <input type="checkbox" id="haIncludeDisabled" style="width:auto; margin-top:7px;" />
            </div>
            <p class="hint">
              Paste Home Assistant JSON (e.g. the array returned by <span class="mono">/api/states</span>). The zone
              topic
              will be the <span class="mono">entity_id</span>. Names use <span
                class="mono">attributes.friendly_name</span>
              if present.
            </p>
          </div>
          <div id="json-mapping">
            <div class="row">
              <label for="topicPath">Topic path</label>
              <select id="topicPath"></select>
            </div>
            <div class="row">
              <label for="valuePath">Value path</label>
              <select id="valuePath"></select>
            </div>
            <div class="row">
              <label for="namePath">Zone name path</label>
              <select id="namePath"></select>
            </div>
          </div>
          <p class="hint">
            Alarm expects zone messages with
            <span class="mono">msg.topic</span> and a boolean value in the
            configured “With Input” property (default
            <span class="mono">payload</span>).
          </p>
          <div class="buttons">
            <label class="mono" style="display:flex; align-items:center; gap:8px;">
              <input type="checkbox" id="appendZones" checked />
              Append to zone list
            </label>
            <button class="primary" id="btn-generate">Generate zones</button>
          </div>
          <div id="gen-status" class="status warn" style="display: none"></div>
        </section>
      </div>
    </div>
  </main>

  <script>
    const els = {
      input: document.getElementById("input"),
      btnParse: document.getElementById("btn-parse"),
      sampleKind: document.getElementById("sampleKind"),
      btnLoadSample: document.getElementById("btn-load-sample"),
      btnClear: document.getElementById("btn-clear"),
      parseStatus: document.getElementById("parse-status"),
      genStatus: document.getElementById("gen-status"),
      topicPath: document.getElementById("topicPath"),
      valuePath: document.getElementById("valuePath"),
      namePath: document.getElementById("namePath"),
      etsHint: document.getElementById("ets-hint"),
      haHint: document.getElementById("ha-hint"),
      etsMapping: document.getElementById("ets-mapping"),
      etsAddressFilter: document.getElementById("etsAddressFilter"),
      etsNameFilter: document.getElementById("etsNameFilter"),
      haMapping: document.getElementById("ha-mapping"),
      haEntityFilter: document.getElementById("haEntityFilter"),
      haNameFilter: document.getElementById("haNameFilter"),
      haDomains: document.getElementById("haDomains"),
      haIncludeDisabled: document.getElementById("haIncludeDisabled"),
      jsonMapping: document.getElementById("json-mapping"),
      appendZones: document.getElementById("appendZones"),
      btnGenerate: document.getElementById("btn-generate"),
      btnZoneAdd: document.getElementById("btn-zone-add"),
      btnWizardToggle: document.getElementById("btn-wizard-toggle"),
      zoneContext: document.getElementById("zone-context"),
      zoneAutosave: document.getElementById("zone-autosave"),
      zoneConnection: document.getElementById("zone-connection"),
      zoneTableBody: document.getElementById("zone-table-body"),
      zoneListStatus: document.getElementById("zone-list-status"),
      wizardStep2: document.getElementById("wizard-step2"),
      wizard: document.getElementById("wizard"),
    };

    const KNX_SAMPLE = `{
  topic: "0/1/2",
  payload: false,
  previouspayload: true,
  payloadmeasureunit: "%",
  payloadsubtypevalue: "Start",
  devicename: "Dinning table lamp",
  gainfo: {
    maingroupname: "Light actuators",
    middlegroupname: "First flow lights",
    ganame: "Table Light",
    maingroupnumber: "1",
    middlegroupnumber: "1",
    ganumber: "0"
  },
  knx: {
    event: "GroupValue_Write",
    dpt: "1.001",
    dptdesc: "Humidity",
    source: "15.15.22",
        destination: "0/1/2",
        rawValue: {
          0: "0x0"
        }
  }
}`;

    const ETS_SAMPLE = `"Group name"\t"Address"\t"Central"\t"Unfiltered"\t"Description"\t"DatapointType"\t"Security"
"Lights"\t"0/-/-"\t""\t""\t""\t""\t"Auto"
"Living room"\t"0/0/-"\t""\t""\t""\t""\t"Auto"
"Front door contact"\t"0/0/1"\t""\t""\t""\t"DPST-1-1"\t"Auto"
"Motion sensor"\t"0/0/2"\t""\t""\t""\t"DPT-1"\t"Auto"
"Dimming value"\t"0/0/3"\t""\t""\t""\t"DPST-5-1"\t"Auto"`;

    const HA_SAMPLE = `[
  {
    "entity_id": "binary_sensor.front_door",
    "state": "off",
    "attributes": {
      "friendly_name": "Front door"
    }
  },
  {
    "entity_id": "binary_sensor.living_pir",
    "state": "on",
    "attributes": {
      "friendly_name": "Living PIR"
    }
  },
  {
    "entity_id": "switch.garden_lights",
    "state": "off",
    "attributes": {
      "friendly_name": "Garden lights"
    }
  }
]`;

    const HA_REGISTRY_SAMPLE = `{
  "data": {
    "entities": [
      {
        "entity_id": "binary_sensor.front_door",
        "name": "Front door",
        "original_name": "Front door contact",
        "disabled_by": null
      },
      {
        "entity_id": "binary_sensor.living_pir",
        "name": "Living PIR",
        "original_name": "Living PIR",
        "disabled_by": null
      },
      {
        "entity_id": "switch.garden_lights",
        "name": "Garden lights",
        "original_name": "Garden lights",
        "disabled_by": "user"
      }
    ]
  },
  "key": "core.entity_registry",
  "version": 1
}`;

    const page = {
      origin: window.location.origin,
      params: new URLSearchParams(window.location.search),
      get alarmNodeId() {
        return String(this.params.get("id") || "").trim();
      },
      get alarmNodeName() {
        return String(this.params.get("name") || "").trim();
      },
      get hasOpener() {
        try {
          return Boolean(window.opener && !window.opener.closed);
        } catch (_err) {
          return false;
        }
      },
    };

    const bc =
      typeof BroadcastChannel === "function"
        ? new BroadcastChannel("alarm-ultimate-zones")
        : null;

    let parsedObject = null;
    let lastGenerated = null;
    let zonesModel = [];
    let autoSaveTimer = null;
    let lastAutoSavedJson = null;
    let zonesJsonText = "[]";
    let editorConnected = false;
    let isEditingZoneTable = false;

    function setAutosaveHint(message) {
      if (!els.zoneAutosave) return;
      if (!message) {
        els.zoneAutosave.style.display = "none";
        els.zoneAutosave.textContent = "";
        return;
      }
      els.zoneAutosave.style.display = "";
      els.zoneAutosave.textContent = message;
    }

    function setConnectionState(state) {
      if (!els.zoneConnection) return;
      const s = String(state || "").trim();
      if (s === "connected") {
        els.zoneConnection.textContent = "Connected";
        els.zoneConnection.className = "pill ok";
        return;
      }
      if (s === "connecting") {
        els.zoneConnection.textContent = "Connecting…";
        els.zoneConnection.className = "pill warn";
        return;
      }
      els.zoneConnection.textContent = "Not connected";
      els.zoneConnection.className = "pill err";
    }

    function canTalkToEditor() {
      return Boolean(page.alarmNodeId) && (page.hasOpener || Boolean(bc));
    }

    function isConnectedToEditor() {
      return Boolean(page.alarmNodeId) && editorConnected === true;
    }

    function normalizeZonesJson(text) {
      const raw = String(text || "").trim();
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) return parsed.filter((z) => z && typeof z === "object");
      if (parsed && typeof parsed === "object") return [parsed];
      return [];
    }

    function buildDefaultZone(index) {
      return {
        name: `Zone ${index + 1}`,
        topic: "",
        type: "perimeter",
        entry: false,
        bypassable: true,
        chime: false,
      };
    }

    function zoneKind(zone) {
      if (zone && zone.entry === true) return "entry";
      const type = zone && typeof zone.type === "string" ? zone.type : "perimeter";
      if (["fire", "tamper", "24h"].includes(type)) return type;
      return "perimeter";
    }

    function applyZoneKind(zone, kind) {
      const k = String(kind || "").trim().toLowerCase();
      if (k === "entry") {
        zone.type = "perimeter";
        zone.entry = true;
        return;
      }
      zone.type = ["fire", "tamper", "24h"].includes(k) ? k : "perimeter";
      zone.entry = false;
    }

	    function cleanZoneForJson(zone, index) {
	      const z = zone && typeof zone === "object" ? { ...zone } : {};
	      const name = String(z.name || "").trim();
	      delete z['id'];

	      if (typeof z.topic === "string") z.topic = z.topic.trim();
	      if (typeof z.topicPattern === "string" && z.topicPattern.trim() && !z.topic) {
	        // Legacy: topicPattern is no longer supported; keep the value as a plain topic.
	        z.topic = z.topicPattern.trim();
	      }
	      delete z.topicPattern;
	      if (z.topic && !z.topic.trim()) delete z.topic;

	      if (!z.topic) {
	        z.topic = "";
	      }

	      z.name = name || String(z.topic || "").trim();

      const type = typeof z.type === "string" ? z.type.trim().toLowerCase() : "perimeter";
      z.type = type || "perimeter";

      z.entry = z.entry === true;
      z.bypassable = z.bypassable !== false;
      z.chime = z.chime === true;

      // Normalize optional supervision config (keeps JSON clean and UI-friendly).
      const supervisionConfig =
        z.supervision && typeof z.supervision === "object"
          ? { ...z.supervision }
          : (z.supervisionEnabled === true ||
            z.supervision === true ||
            z.supervisionBlockArm !== undefined ||
            z.supervisionTimeoutSeconds !== undefined ||
            z.supervisionSeconds !== undefined)
            ? {
              enabled: z.supervisionEnabled === true || z.supervision === true,
              timeoutSeconds:
                z.supervisionTimeoutSeconds !== undefined
                  ? z.supervisionTimeoutSeconds
                  : z.supervisionSeconds !== undefined
                    ? z.supervisionSeconds
                    : undefined,
              blockArm: z.supervisionBlockArm,
            }
            : null;

      if (supervisionConfig && supervisionConfig.enabled === true) {
        const timeoutSeconds = Number(supervisionConfig.timeoutSeconds);
        const blockArm = Object.prototype.hasOwnProperty.call(supervisionConfig, "blockArm")
          ? supervisionConfig.blockArm !== false
          : true;
        z.supervision = {
          enabled: true,
          timeoutSeconds: Number.isFinite(timeoutSeconds) && timeoutSeconds > 0 ? timeoutSeconds : null,
          blockArm,
        };
        if (z.supervision.timeoutSeconds === null) delete z.supervision.timeoutSeconds;
      } else {
        delete z.supervision;
      }

      // Drop legacy supervision fields (we keep only `supervision`).
      delete z.supervisionEnabled;
      delete z.supervisionTimeoutSeconds;
      delete z.supervisionSeconds;
      delete z.supervisionBlockArm;

      // Drop UI-only fields if any.
      delete z.__errors;
      return z;
    }

    function syncJsonFromModel() {
      const payload = zonesModel
        .map((z, idx) => {
          const cleaned = cleanZoneForJson(z, idx);
          return cleaned;
        })
        .filter((z) => z && typeof z === "object");

      zonesJsonText = payload.length === 1 ? JSON.stringify(payload[0], null, 2) : JSON.stringify(payload, null, 2);
      return payload;
    }

    function scheduleAutosave(errors) {
      if (isEditingZoneTable) {
        if (autoSaveTimer) window.clearTimeout(autoSaveTimer);
        autoSaveTimer = null;
        setAutosaveHint("Autosave paused while editing zones.");
        return;
      }
      if (!page.alarmNodeId) {
        setAutosaveHint("");
        setConnectionState("disconnected");
        return;
      }
      if (!canTalkToEditor()) {
        setAutosaveHint("Autosave unavailable: open this page from the Alarm node editor.");
        setConnectionState("disconnected");
        return;
      }
      if (!isConnectedToEditor()) {
        setConnectionState("connecting");
      }
      if (errors && errors.length > 0) {
        setAutosaveHint("Autosave paused: fix zone errors to save.");
        return;
      }
      if (autoSaveTimer) window.clearTimeout(autoSaveTimer);
      autoSaveTimer = window.setTimeout(() => {
        autoSaveTimer = null;
        sendZonesToEditor(true);
      }, 80);
    }

    function flushZonesToEditor(quiet) {
      if (!page.alarmNodeId) return;
      if (!canTalkToEditor()) return;
      const errors = validateModel();
      if (errors && errors.length > 0) return;
      if (autoSaveTimer) window.clearTimeout(autoSaveTimer);
      autoSaveTimer = null;
      sendZonesToEditor(quiet !== false);
    }

	    function validateModel() {
	      const errors = [];
	      zonesModel.forEach((zone, idx) => {
	        zone.__errors = [];
	        const topic = String(zone.topic || "").trim();
	        if (!topic) zone.__errors.push("Missing topic.");

	        const sup = zone && zone.supervision && typeof zone.supervision === "object" ? zone.supervision : null;
	        if (sup && sup.enabled === true) {
	          const t = Number(sup.timeoutSeconds);
          if (!(Number.isFinite(t) && t > 0)) {
            zone.__errors.push("Supervision enabled but timeoutSeconds is missing/invalid.");
          }
        }
      });

	      // Detect duplicates (same topic configured more than once).
	      const seen = new Map();
	      zonesModel.forEach((zone, idx) => {
	        const key = String(zone.topic || "").trim();
	        if (!key) return;
	        if (!seen.has(key)) seen.set(key, []);
	        seen.get(key).push(idx);
	      });
	      for (const [key, indexes] of seen.entries()) {
	        if (indexes.length <= 1) continue;
	        indexes.forEach((idx) => {
	          zonesModel[idx].__errors.push(`Duplicate topic: ${key}`);
	        });
	      }

      zonesModel.forEach((z) => {
        if (z.__errors && z.__errors.length) errors.push(...z.__errors);
      });
      return errors;
    }

    function refreshZonesMeta() {
      const errors = validateModel();
      syncJsonFromModel();
      if (errors.length === 0) {
        hideStatus(els.zoneListStatus);
      } else {
        showStatus(
          els.zoneListStatus,
          "warn",
          `Zones: ${errors[0]}${errors.length > 1 ? ` (+${errors.length - 1} more)` : ""}`,
        );
      }
      scheduleAutosave(errors);
    }

	    function renderZones() {
	      els.zoneTableBody.innerHTML = "";

	      zonesModel.forEach((zone, index) => {
	        const tr = document.createElement("tr");
	        tr.dataset.index = String(index);

	        const tdValue = document.createElement("td");
	        const valueInput = document.createElement("input");
	        valueInput.type = "text";
	        valueInput.value = String(zone.topic || "");
	        valueInput.placeholder = "sensor/frontdoor  or  0/1/*";
	        valueInput.dataset.field = "topicValue";
	        tdValue.appendChild(valueInput);

        const tdName = document.createElement("td");
        const nameInput = document.createElement("input");
        nameInput.type = "text";
        nameInput.value = String(zone.name || "");
        nameInput.placeholder = "Front door";
        nameInput.dataset.field = "name";
        tdName.appendChild(nameInput);

        const tdKind = document.createElement("td");
        const kindSelect = document.createElement("select");
        kindSelect.dataset.field = "kind";
        [
          ["perimeter", "Perimeter"],
          ["entry", "Entry"],
          ["24h", "24h"],
          ["tamper", "Tamper"],
          ["fire", "Fire"],
        ].forEach(([value, label]) => {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;
          kindSelect.appendChild(opt);
        });
        kindSelect.value = zoneKind(zone);
        tdKind.appendChild(kindSelect);

        const tdSup = document.createElement("td");
        const sup = zone && zone.supervision && typeof zone.supervision === "object" ? zone.supervision : null;
        const supEnabled = Boolean(sup && sup.enabled === true);
        const supTimeout =
          sup && sup.enabled === true && Number.isFinite(Number(sup.timeoutSeconds)) ? String(Number(sup.timeoutSeconds)) : "";
        const supBlockArm =
          sup && sup.enabled === true && Object.prototype.hasOwnProperty.call(sup, "blockArm") ? sup.blockArm !== false : true;

        const supWrap = document.createElement("div");
        supWrap.className = "zone-sup";

        const supEnabledLabel = document.createElement("label");
        const supEnabledCb = document.createElement("input");
        supEnabledCb.type = "checkbox";
        supEnabledCb.checked = supEnabled;
        supEnabledCb.dataset.field = "supEnabled";
        supEnabledLabel.appendChild(supEnabledCb);
        supEnabledLabel.appendChild(document.createTextNode("On"));

        const supTimeWrap = document.createElement("div");
        supTimeWrap.className = "sup-time";
        const supTimeoutInput = document.createElement("input");
        supTimeoutInput.type = "number";
        supTimeoutInput.min = "0";
        supTimeoutInput.step = "1";
        supTimeoutInput.placeholder = "120";
        supTimeoutInput.value = supTimeout;
        supTimeoutInput.dataset.field = "supTimeout";
        supTimeoutInput.disabled = !supEnabled;
        const supS = document.createElement("span");
        supS.textContent = "s";
        supTimeWrap.appendChild(supTimeoutInput);
        supTimeWrap.appendChild(supS);

        const supBlockLabel = document.createElement("label");
        const supBlockCb = document.createElement("input");
        supBlockCb.type = "checkbox";
        supBlockCb.checked = supEnabled ? supBlockArm : true;
        supBlockCb.dataset.field = "supBlockArm";
        supBlockCb.disabled = !supEnabled;
        supBlockLabel.appendChild(supBlockCb);
        supBlockLabel.appendChild(document.createTextNode("Block arm"));

        supWrap.appendChild(supEnabledLabel);
        supWrap.appendChild(supTimeWrap);
        supWrap.appendChild(supBlockLabel);
        tdSup.appendChild(supWrap);

        const tdActions = document.createElement("td");
        const delBtn = document.createElement("button");
        delBtn.type = "button";
        delBtn.textContent = "Delete";
        delBtn.className = "btn-danger";
        delBtn.dataset.action = "delete";
        tdActions.appendChild(delBtn);

		        tr.appendChild(tdValue);
		        tr.appendChild(tdName);
		        tr.appendChild(tdKind);
		        tr.appendChild(tdSup);
		        tr.appendChild(tdActions);

        els.zoneTableBody.appendChild(tr);
      });

      refreshZonesMeta();
    }

    function setZonesFromJson(text) {
      const zones = normalizeZonesJson(text);
      zonesModel = zones.map((z, idx) => cleanZoneForJson(z, idx));
      renderZones();
    }

    function addZone(zone) {
      const next = zone && typeof zone === "object" ? cleanZoneForJson(zone, zonesModel.length) : buildDefaultZone(zonesModel.length);
      zonesModel.push(next);
      renderZones();
      // Focus new row topic field.
      try {
        const rows = els.zoneTableBody.querySelectorAll("tr");
        const last = rows[rows.length - 1];
        const input = last ? last.querySelector('input[data-field="topicValue"]') : null;
        if (input) input.focus();
      } catch (_err) { }
    }

    function sendZonesToEditor(quiet) {
      if (!page.alarmNodeId) return;
      if (!canTalkToEditor()) {
        setAutosaveHint("Autosave unavailable: open this page from the Alarm node editor.");
        setConnectionState("disconnected");
        return;
      }
      if (!isConnectedToEditor()) {
        setConnectionState("connecting");
      }

      const payload = syncJsonFromModel();
      const json = zonesJsonText;
      if (lastAutoSavedJson === json) {
        setAutosaveHint(`Autosave: saved ${payload.length} zones.`);
        return;
      }
      try {
        if (page.hasOpener) {
          window.opener.postMessage(
            { type: "alarm-ultimate-zones", nodeId: page.alarmNodeId, zonesJson: json, zones: payload },
            page.origin,
          );
        }
      } catch (_err) {
        // ignore
      }
      try {
        if (bc) {
          bc.postMessage({ type: "alarm-ultimate-zones", nodeId: page.alarmNodeId, zonesJson: json, zones: payload });
        }
      } catch (_err) {
        // ignore
      }
      lastAutoSavedJson = json;
      setAutosaveHint(`Autosave: saved ${payload.length} zones.`);
      if (!quiet) {
        showStatus(els.genStatus, "ok", `Saved ${payload.length} zones to Alarm editor.`);
      }
    }

    function requestZonesFromEditor() {
      if (!page.alarmNodeId) return;
      if (!canTalkToEditor()) {
        setAutosaveHint("Autosave unavailable: open this page from the Alarm node editor.");
        setConnectionState("disconnected");
        return;
      }
      setConnectionState("connecting");
      try {
        if (page.hasOpener) {
          window.opener.postMessage({ type: "alarm-ultimate-request-zones", nodeId: page.alarmNodeId }, page.origin);
        }
      } catch (_err) {
        // ignore
      }
      try {
        if (bc) {
          bc.postMessage({ type: "alarm-ultimate-request-zones", nodeId: page.alarmNodeId });
        }
      } catch (_err) {
        // ignore
      }
      setAutosaveHint("Autosave: loading zones from Alarm...");
    }

    function showStatus(el, kind, message) {
      el.style.display = "";
      el.className = `status ${kind}`;
      el.textContent = message;
    }

    function hideStatus(el) {
      el.style.display = "none";
      el.textContent = "";
    }

    function normalizeLenientJson(input) {
      let text = String(input || "");
      text = text.replace(/\r\n/g, "\n");
      text = text.replace(/\/\*[\s\S]*?\*\//g, "");
      text = text.replace(/(^|[^:])\/\/.*$/gm, "$1");

      text = text.replace(/([{,]\s*)([A-Za-z_$][\w$]*)(\s*:)/g, '$1"$2"$3');
      text = text.replace(/([{,]\s*)(\d+)(\s*:)/g, '$1"$2"$3');

      text = text.replace(/:\s*0x([0-9a-fA-F]+)\b/g, ': "0x$1"');

      return text;
    }

    function parseInput(text) {
      const raw = String(text || "").trim();
      if (!raw) return { ok: false, error: "Empty input." };

      try {
        return {
          ok: true,
          value: JSON.parse(raw),
          note: "Parsed as strict JSON.",
        };
      } catch (err1) {
        try {
          const normalized = normalizeLenientJson(raw);
          const value = JSON.parse(normalized);
          return {
            ok: true,
            value,
            note: "Parsed after normalizing (removed comments, quoted keys).",
          };
        } catch (err2) {
          const ets = parseEtsExport(raw);
          if (ets.ok) {
            return { ok: true, value: { __ets: true, ets }, note: ets.note };
          }
          return {
            ok: false,
            error:
              "Unable to parse. Please paste strict JSON, or a JS-style object with only // comments and unquoted keys.",
            details: String(err2 && err2.message ? err2.message : err2),
          };
        }
      }
    }

    function normalizeHeaderKey(value) {
      return String(value || "")
        .trim()
        .toLowerCase()
        .replace(/^\ufeff/, "")
        .replace(/[^a-z0-9]/g, "");
    }

    function parseDelimitedLine(line, delimiter) {
      const out = [];
      let cur = "";
      let inQuotes = false;
      for (let i = 0; i < line.length; i += 1) {
        const ch = line[i];
        if (inQuotes) {
          if (ch === '"') {
            const next = line[i + 1];
            if (next === '"') {
              cur += '"';
              i += 1;
            } else {
              inQuotes = false;
            }
          } else {
            cur += ch;
          }
        } else {
          if (ch === '"') {
            inQuotes = true;
          } else if (ch === delimiter) {
            out.push(cur.trim());
            cur = "";
          } else {
            cur += ch;
          }
        }
      }
      out.push(cur.trim());
      return out;
    }

    function detectDelimiter(headerLine) {
      const line = String(headerLine || "");
      if (line.includes("\t")) return "\t";
      if (line.includes(";")) return ";";
      if (line.includes(",")) return ",";
      return "\t";
    }

    function isBooleanDatapointType(value) {
      const t = String(value || "")
        .trim()
        .toLowerCase();
      if (!t) return false;
      return (
        t === "dpt-1" ||
        t.startsWith("dpt-1-") ||
        t.startsWith("dpst-1-") ||
        /^1\.\d+/.test(t)
      );
    }

    function parseEtsExport(text) {
      const raw = String(text || "")
        .replace(/\r\n/g, "\n")
        .replace(/\r/g, "\n")
        .trim();

      const lines = raw
        .split("\n")
        .map((l) => l.trim())
        .filter((l) => l.length > 0);

      if (lines.length < 2) return { ok: false };

      const headerLine = lines[0];
      const delimiter = detectDelimiter(headerLine);
      const headers = parseDelimitedLine(headerLine, delimiter);
      const keyByIndex = headers.map(normalizeHeaderKey);

      const idxGroupName = keyByIndex.indexOf("groupname");
      const idxAddress = keyByIndex.indexOf("address");
      const idxDescription = keyByIndex.indexOf("description");
      const idxDatapointType = keyByIndex.indexOf("datapointtype");

      if (idxGroupName < 0 || idxAddress < 0) return { ok: false };

      const rows = [];
      for (let i = 1; i < lines.length; i += 1) {
        const cols = parseDelimitedLine(lines[i], delimiter);
        const groupName = cols[idxGroupName] || "";
        const address = cols[idxAddress] || "";
        const description =
          idxDescription >= 0 ? cols[idxDescription] || "" : "";
        const datapointType =
          idxDatapointType >= 0 ? cols[idxDatapointType] || "" : "";

        rows.push({ groupName, address, description, datapointType });
      }

      return {
        ok: true,
        note: "Detected ETS Group Addresses export (TSV).",
        rows,
      };
    }

    function escapeRegExp(value) {
      return String(value || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function globToRegExp(glob) {
      const raw = String(glob || "").trim();
      if (!raw) return null;
      let pattern = "";
      for (let i = 0; i < raw.length; i += 1) {
        const ch = raw[i];
        if (ch === "*") pattern += ".*";
        else if (ch === "?") pattern += ".";
        else pattern += escapeRegExp(ch);
      }
      try {
        return new RegExp(`^${pattern}$`, "i");
      } catch (_err) {
        return null;
      }
    }

    function splitPatterns(text) {
      return String(text || "")
        .split(/[\n,]+/g)
        .map((p) => p.trim())
        .filter((p) => p.length > 0);
    }

    function matchesAnyGlob(value, patterns) {
      if (!patterns || patterns.length === 0) return true;
      const target = String(value || "").trim();
      if (!target) return false;
      for (const p of patterns) {
        const re = globToRegExp(p);
        if (re && re.test(target)) return true;
      }
      return false;
    }

    function matchesNameFilter(row, nameFilterRaw) {
      const filter = String(nameFilterRaw || "").trim();
      if (!filter) return true;
      const name = String(row && (row.description || row.groupName) ? row.description || row.groupName : "")
        .trim()
        .toLowerCase();
      if (!name) return false;
      if (filter.includes("*") || filter.includes("?")) {
        const re = globToRegExp(filter);
        return Boolean(re && re.test(name));
      }
      return name.includes(filter.toLowerCase());
    }

    function extractHomeAssistantStates(value) {
      if (Array.isArray(value)) return value;
      if (value && typeof value === "object") {
        if (Array.isArray(value.result)) return value.result;
        if (Array.isArray(value.states)) return value.states;
        if (Array.isArray(value.entities)) return value.entities;
      }
      return null;
    }

    function isHomeAssistantStatesExport(value) {
      const states = extractHomeAssistantStates(value);
      if (!states || states.length === 0) return false;
      const sample = states.slice(0, 10);
      return sample.some((s) => s && typeof s === "object" && typeof s.entity_id === "string");
    }

    function extractHomeAssistantEntityRegistry(value) {
      if (!value || typeof value !== "object") return null;
      if (Array.isArray(value.entities)) return value.entities;
      if (value.data && Array.isArray(value.data.entities)) return value.data.entities;
      if (value.result && value.result.data && Array.isArray(value.result.data.entities)) return value.result.data.entities;
      return null;
    }

    function isHomeAssistantEntityRegistryExport(value) {
      const entities = extractHomeAssistantEntityRegistry(value);
      if (!entities || entities.length === 0) return false;
      const sample = entities.slice(0, 10);
      return sample.some((e) => e && typeof e === "object" && typeof e.entity_id === "string");
    }

    function getHaDomain(entityId) {
      const id = String(entityId || "");
      const idx = id.indexOf(".");
      if (idx <= 0) return "";
      return id.slice(0, idx).toLowerCase();
    }

    function parseDomainList(input) {
      return String(input || "")
        .split(/[\s,]+/g)
        .map((d) => d.trim().toLowerCase())
        .filter((d) => d.length > 0);
    }

    function isPlainObject(value) {
      return (
        Boolean(value) && typeof value === "object" && !Array.isArray(value)
      );
    }

    function enumeratePaths(value, basePath = "", out = []) {
      if (value === null || value === undefined) {
        out.push(basePath || "(root)");
        return out;
      }
      if (typeof value !== "object") {
        out.push(basePath || "(root)");
        return out;
      }

      if (Array.isArray(value)) {
        out.push(basePath || "(root)");
        const limit = Math.min(20, value.length);
        for (let i = 0; i < limit; i += 1) {
          enumeratePaths(value[i], `${basePath}[${i}]`, out);
        }
        return out;
      }

      out.push(basePath || "(root)");
      const keys = Object.keys(value).slice(0, 200);
      for (const key of keys) {
        const next = basePath ? `${basePath}.${key}` : key;
        enumeratePaths(value[key], next, out);
      }
      return out;
    }

    function getByPath(obj, path) {
      if (!path || path === "(root)") return obj;
      const parts = [];
      String(path)
        .split(".")
        .forEach((segment) => {
          const m = segment.match(/^([^[\]]+)(\[(\d+)\])?$/);
          if (!m) {
            parts.push(segment);
            return;
          }
          parts.push(m[1]);
          if (m[2]) parts.push(Number(m[3]));
        });

      let cur = obj;
      for (const part of parts) {
        if (cur === null || cur === undefined) return undefined;
        cur = cur[part];
      }
      return cur;
    }

    function toOneLine(value) {
      if (value === undefined) return "undefined";
      if (typeof value === "string") return value;
      try {
        return JSON.stringify(value);
      } catch (err) {
        return String(value);
      }
    }

    function guessDefault(paths, candidates) {
      for (const c of candidates) {
        if (paths.includes(c)) return c;
      }
      return paths.includes("topic") ? "topic" : paths[0] || "(root)";
    }

    function setSelectOptions(select, paths, selected) {
      select.innerHTML = "";
      for (const p of paths) {
        const opt = document.createElement("option");
        opt.value = p;
        opt.textContent = p;
        select.appendChild(opt);
      }
      select.value = selected;
    }

    function buildZoneTemplate(normalizedMsg, zoneNameValue) {
      const topic =
        normalizedMsg && normalizedMsg.topic
          ? String(normalizedMsg.topic)
          : "";
      const name =
        zoneNameValue !== undefined &&
          zoneNameValue !== null &&
          String(zoneNameValue).trim().length > 0
          ? String(zoneNameValue).trim()
          : topic || "Zone";

      return {
        name,
        topic,
        type: "perimeter",
        entry: false,
        bypassable: true,
        chime: false,
      };
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (err) {
        return false;
      }
    }

    function renderJson(el, obj) {
      el.style.display = "";
      el.className = "status ok";
      el.innerHTML = "";
      const pre = document.createElement("pre");
      pre.textContent = JSON.stringify(obj, null, 2);
      el.appendChild(pre);
    }

    function renderText(el, text) {
      el.style.display = "";
      el.className = "status ok";
      el.innerHTML = "";
      const pre = document.createElement("pre");
      pre.textContent = String(text || "");
      el.appendChild(pre);
    }

    function parseAndPopulate() {
      hideStatus(els.parseStatus);
      hideStatus(els.genStatus);
      hideStatus(els.etsHint);
      hideStatus(els.haHint);
      if (els.wizardStep2) els.wizardStep2.classList.add("disabled");
      els.jsonMapping.style.display = "";
      els.etsMapping.style.display = "none";
      els.haMapping.style.display = "none";
      lastGenerated = null;

      const result = parseInput(els.input.value);
      if (!result.ok) {
        parsedObject = null;
        showStatus(
          els.parseStatus,
          "err",
          `${result.error}${result.details ? "\n" + result.details : ""}`,
        );
        return;
      }

      if (els.wizardStep2) els.wizardStep2.classList.remove("disabled");

      if (
        result.value &&
        result.value.__ets &&
        result.value.ets &&
        Array.isArray(result.value.ets.rows)
      ) {
        parsedObject = result.value;
        showStatus(els.parseStatus, "ok", result.note);
        els.jsonMapping.style.display = "none";
        els.etsMapping.style.display = "";
        els.haMapping.style.display = "none";
        showStatus(
          els.etsHint,
          "ok",
          "ETS import mode: mapping is fixed.\n- Topic: Address (e.g. 0/0/1)\n- Name: Description, fallback to Group name\nClick “Generate output” to create a zones JSON array.",
        );
        return;
      }

      if (isHomeAssistantStatesExport(result.value)) {
        parsedObject = { __ha: true, ha: { kind: "states", states: extractHomeAssistantStates(result.value) } };
        showStatus(els.parseStatus, "ok", "Detected Home Assistant states export (JSON).");
        els.jsonMapping.style.display = "none";
        els.etsMapping.style.display = "none";
        els.haMapping.style.display = "";
        showStatus(
          els.haHint,
          "ok",
          "Home Assistant import mode.\n- Topic: entity_id\n- Name: attributes.friendly_name (fallback entity_id)\nUse the filters below, then click “Generate output”.",
        );
        return;
      }

      if (isHomeAssistantEntityRegistryExport(result.value)) {
        parsedObject = { __ha: true, ha: { kind: "entity_registry", entities: extractHomeAssistantEntityRegistry(result.value) } };
        showStatus(els.parseStatus, "ok", "Detected Home Assistant entity registry export (core.entity_registry).");
        els.jsonMapping.style.display = "none";
        els.etsMapping.style.display = "none";
        els.haMapping.style.display = "";
        showStatus(
          els.haHint,
          "ok",
          "Home Assistant import mode (entity registry).\n- Topic: entity_id\n- Name: name/original_name (fallback entity_id)\nUse the filters below, then click “Generate output”.",
        );
        return;
      }

      els.topicPath.disabled = false;
      els.valuePath.disabled = false;
      els.namePath.disabled = false;

      if (!isPlainObject(result.value)) {
        parsedObject = result.value;
        showStatus(
          els.parseStatus,
          "warn",
          `${result.note} Note: the root is not an object. Paths will be limited.`,
        );
      } else {
        parsedObject = result.value;
        showStatus(els.parseStatus, "ok", result.note);
      }

      const paths = Array.from(new Set(enumeratePaths(parsedObject))).filter(
        Boolean,
      );
      paths.sort((a, b) => a.localeCompare(b));

      const defaultTopic = guessDefault(paths, [
        "topic",
        "knx.destination",
        "destination",
      ]);
      const defaultValue = guessDefault(paths, [
        "payload",
        "payloadsubtypevalue",
        "value",
      ]);
      const defaultName = guessDefault(paths, [
        "devicename",
        "gainfo.ganame",
        "name",
        "topic",
      ]);

      setSelectOptions(els.topicPath, paths, defaultTopic);
      setSelectOptions(els.valuePath, paths, defaultValue);
      setSelectOptions(els.namePath, paths, defaultName);
    }

    function generate() {
      hideStatus(els.genStatus);
      if (!parsedObject) {
        showStatus(els.genStatus, "err", "Parse a valid message first.");
        return;
      }
      const append = els.appendZones ? els.appendZones.checked === true : true;

      if (
        parsedObject &&
        parsedObject.__ets &&
        parsedObject.ets &&
        Array.isArray(parsedObject.ets.rows)
      ) {
        const allRows = parsedObject.ets.rows;
        const addressPatterns = splitPatterns(
          els.etsAddressFilter ? els.etsAddressFilter.value : "",
        );
        const nameFilter = els.etsNameFilter ? els.etsNameFilter.value : "";

        const leafRows = allRows.filter((r) => {
          const addr = String(r && r.address ? r.address : "").trim();
          if (!addr) return false;
          if (addr.includes("-")) return false;
          return /^\d+\/\d+\/\d+$/.test(addr);
        });

        const booleanRows = leafRows.filter((r) =>
          isBooleanDatapointType(r.datapointType),
        );
        const filteredRows = booleanRows.filter((r) => {
          const addr = String(r && r.address ? r.address : "").trim();
          if (!matchesAnyGlob(addr, addressPatterns)) return false;
          if (!matchesNameFilter(r, nameFilter)) return false;
          return true;
        });

	        const zones = filteredRows.map((row) => {
	          const address = String(row.address).trim();
	          const topic = address;
	          const nameCandidate =
	            String(row.description || "").trim() ||
	            String(row.groupName || "").trim();
	          const name = nameCandidate || address;
	          return {
	            name,
	            topic,
	            type: "perimeter",
	            entry: false,
	            bypassable: true,
	            chime: false,
	          };
	        });

	        if (append) {
	          const start = zonesModel.length;
	          zonesModel = zonesModel.concat(
	            zones.map((z, idx) => {
	              return cleanZoneForJson(z, start + idx);
	            }),
	          );
	          renderZones();
	        } else {
	          zonesModel = zones.map((z, idx) => cleanZoneForJson(z, idx));
	          renderZones();
	        }
        const skippedGroups = allRows.length - leafRows.length;
        const skippedNonBoolean = leafRows.length - booleanRows.length;
        const skippedByFilters = booleanRows.length - filteredRows.length;
        showStatus(
          els.genStatus,
          zones.length ? "ok" : "warn",
          `${append ? "Appended" : "Replaced with"} ${zones.length} zones from ETS (skipped ${skippedGroups} group rows, ${skippedNonBoolean} non-boolean datapoints, ${skippedByFilters} filtered out).`,
        );
        return;
      }

      if (parsedObject && parsedObject.__ha && parsedObject.ha && parsedObject.ha.kind === "states" && Array.isArray(parsedObject.ha.states)) {
        const states = parsedObject.ha.states;
        const entityPatterns = splitPatterns(els.haEntityFilter ? els.haEntityFilter.value : "");
        const nameFilter = els.haNameFilter ? els.haNameFilter.value : "";
        const domains = parseDomainList(els.haDomains ? els.haDomains.value : "");
        const defaultBooleanDomains = ["binary_sensor", "input_boolean", "switch"];
        const allowedDomains = domains.length ? domains : defaultBooleanDomains;

        const eligible = states.filter((s) => s && typeof s === "object" && typeof s.entity_id === "string");
        const domainFiltered = eligible.filter((s) => allowedDomains.includes(getHaDomain(s.entity_id)));
        const filtered = domainFiltered.filter((s) => {
          const entityId = String(s.entity_id || "").trim();
          if (!matchesAnyGlob(entityId, entityPatterns)) return false;
          const row = { description: s.attributes && s.attributes.friendly_name ? s.attributes.friendly_name : "", groupName: entityId };
          if (!matchesNameFilter(row, nameFilter)) return false;
          return true;
        });

	        const zones = filtered.map((s) => {
	          const entityId = String(s.entity_id).trim();
	          const friendly = s.attributes && s.attributes.friendly_name ? String(s.attributes.friendly_name).trim() : "";
	          const name = friendly || entityId;
	          return {
	            name,
	            topic: entityId,
	            type: "perimeter",
	            entry: false,
	            bypassable: true,
            chime: false,
          };
        });

	        if (append) {
	          const start = zonesModel.length;
	          zonesModel = zonesModel.concat(
	            zones.map((z, idx) => {
	              return cleanZoneForJson(z, start + idx);
	            }),
	          );
	          renderZones();
	        } else {
	          zonesModel = zones.map((z, idx) => cleanZoneForJson(z, idx));
	          renderZones();
	        }
        const skippedNonEntity = states.length - eligible.length;
        const skippedDomain = eligible.length - domainFiltered.length;
        const skippedByFilters = domainFiltered.length - filtered.length;
        showStatus(
          els.genStatus,
          zones.length ? "ok" : "warn",
          `Generated ${zones.length} zones from HA (skipped ${skippedNonEntity} invalid rows, ${skippedDomain} domain filtered, ${skippedByFilters} filtered out).`,
        );
        return;
      }

      if (parsedObject && parsedObject.__ha && parsedObject.ha && parsedObject.ha.kind === "entity_registry" && Array.isArray(parsedObject.ha.entities)) {
        const entities = parsedObject.ha.entities;
        const includeDisabled = Boolean(els.haIncludeDisabled && els.haIncludeDisabled.checked);
        const entityPatterns = splitPatterns(els.haEntityFilter ? els.haEntityFilter.value : "");
        const nameFilter = els.haNameFilter ? els.haNameFilter.value : "";
        const domains = parseDomainList(els.haDomains ? els.haDomains.value : "");
        const defaultBooleanDomains = ["binary_sensor", "input_boolean", "switch"];
        const allowedDomains = domains.length ? domains : defaultBooleanDomains;

        const eligible = entities.filter((e) => e && typeof e === "object" && typeof e.entity_id === "string");
        const enabledOnly = eligible.filter((e) => includeDisabled || !e.disabled_by);
        const domainFiltered = enabledOnly.filter((e) => allowedDomains.includes(getHaDomain(e.entity_id)));
        const filtered = domainFiltered.filter((e) => {
          const entityId = String(e.entity_id || "").trim();
          if (!matchesAnyGlob(entityId, entityPatterns)) return false;
          const displayName = String(e.name || "").trim() || String(e.original_name || "").trim() || entityId;
          const row = { description: displayName, groupName: entityId };
          if (!matchesNameFilter(row, nameFilter)) return false;
          return true;
        });

	        const zones = filtered.map((e) => {
	          const entityId = String(e.entity_id).trim();
	          const displayName = String(e.name || "").trim() || String(e.original_name || "").trim() || entityId;
	          return {
	            name: displayName,
	            topic: entityId,
	            type: "perimeter",
            entry: false,
            bypassable: true,
            chime: false,
          };
        });

	        if (append) {
	          const start = zonesModel.length;
	          zonesModel = zonesModel.concat(
	            zones.map((z, idx) => {
	              return cleanZoneForJson(z, start + idx);
	            }),
	          );
	          renderZones();
	        } else {
	          zonesModel = zones.map((z, idx) => cleanZoneForJson(z, idx));
	          renderZones();
	        }
        const skippedNonEntity = entities.length - eligible.length;
        const skippedDisabled = eligible.length - enabledOnly.length;
        const skippedDomain = enabledOnly.length - domainFiltered.length;
        const skippedByFilters = domainFiltered.length - filtered.length;
        showStatus(
          els.genStatus,
          zones.length ? "ok" : "warn",
          `Generated ${zones.length} zones from HA registry (skipped ${skippedNonEntity} invalid rows, ${skippedDisabled} disabled, ${skippedDomain} domain filtered, ${skippedByFilters} filtered out).`,
        );
        return;
      }

      const topicPath = els.topicPath.value;
      const valuePath = els.valuePath.value;
      const namePath = els.namePath.value;

      const topicValue = getByPath(parsedObject, topicPath);
      const valueValue = getByPath(parsedObject, valuePath);
      const nameValue = getByPath(parsedObject, namePath);

      if (topicValue === undefined) {
        showStatus(
          els.genStatus,
          "err",
          `Topic path "${topicPath}" is undefined in the input message.`,
        );
        return;
      }

      const normalized = {
        ...parsedObject,
        topic: String(topicValue),
        payload: valueValue,
      };
      const zone = buildZoneTemplate(normalized, nameValue);
      if (append) {
        addZone(zone);
	      } else {
	        const cleaned = cleanZoneForJson(zone, 0);
	        zonesModel = [cleaned];
	        renderZones();
	      }

      lastGenerated = { normalized, zone };
      showStatus(
        els.genStatus,
        "ok",
        `${append ? "Appended" : "Replaced with"} 1 zone using topic="${toOneLine(topicValue)}" and value="${valuePath}".`,
      );
    }

    els.btnParse.addEventListener("click", () => parseAndPopulate());
    els.btnGenerate.addEventListener("click", () => generate());
    els.btnClear.addEventListener("click", () => {
      els.input.value = "";
      parsedObject = null;
      lastGenerated = null;
      hideStatus(els.parseStatus);
      hideStatus(els.genStatus);
      hideStatus(els.etsHint);
      hideStatus(els.haHint);
      if (els.wizardStep2) els.wizardStep2.classList.add("disabled");
      els.jsonMapping.style.display = "";
      els.etsMapping.style.display = "none";
      if (els.etsAddressFilter) els.etsAddressFilter.value = "";
      if (els.etsNameFilter) els.etsNameFilter.value = "";
      els.haMapping.style.display = "none";
      if (els.haEntityFilter) els.haEntityFilter.value = "";
      if (els.haNameFilter) els.haNameFilter.value = "";
      if (els.haDomains) els.haDomains.value = "";
      if (els.haIncludeDisabled) els.haIncludeDisabled.checked = false;
      els.topicPath.innerHTML = "";
      els.valuePath.innerHTML = "";
      els.namePath.innerHTML = "";
      els.topicPath.disabled = false;
      els.valuePath.disabled = false;
      els.namePath.disabled = false;
    });

    function loadSample(kind) {
      const k = String(kind || "").trim();
      if (k === "knx") els.input.value = KNX_SAMPLE;
      else if (k === "ets") els.input.value = ETS_SAMPLE;
      else if (k === "ha") els.input.value = HA_SAMPLE;
      else if (k === "ha_registry") els.input.value = HA_REGISTRY_SAMPLE;
      else return;
      parseAndPopulate();
    }

    els.btnLoadSample.addEventListener("click", () => loadSample(els.sampleKind ? els.sampleKind.value : ""));

    els.btnZoneAdd.addEventListener("click", () => addZone(null));

    function toggleWizard(forceOpen) {
      if (!els.wizard) return;
      const isOpen = els.wizard.style.display !== "none";
      const nextOpen = forceOpen === true ? true : forceOpen === false ? false : !isOpen;
      els.wizard.style.display = nextOpen ? "" : "none";
      if (els.btnWizardToggle) {
        els.btnWizardToggle.textContent = nextOpen ? "Hide import wizard" : "Import zones wizard";
      }
      if (nextOpen) {
        setTimeout(() => {
          try {
            els.wizard.scrollIntoView({ behavior: "smooth", block: "start" });
            if (els.input) els.input.focus();
          } catch (_err) {
            // ignore
          }
        }, 0);
      }
    }

    if (els.btnWizardToggle) {
      els.btnWizardToggle.addEventListener("click", () => toggleWizard());
    }

	    // Use input for text fields, change for selects.
	    els.zoneTableBody.addEventListener("input", (evt) => {
	      const target = evt.target;
	      if (!target) return;
      const tr = target.closest("tr");
      if (!tr) return;
      const index = Number(tr.dataset.index);
      if (!Number.isInteger(index) || index < 0 || index >= zonesModel.length) return;
      const zone = zonesModel[index];

	      const field = target.dataset.field;
	      if (field === "name") {
	        zone.name = String(target.value || "");
	      } else if (field === "topicValue") {
	        zone.topic = String(target.value || "");
	      } else if (field === "kind") {
	        applyZoneKind(zone, target.value);
	      } else if (field === "supTimeout") {
        if (!zone.supervision || typeof zone.supervision !== "object") {
          zone.supervision = { enabled: true };
        }
        zone.supervision.enabled = true;
        const t = Number(target.value);
        if (Number.isFinite(t) && t > 0) {
          zone.supervision.timeoutSeconds = t;
        } else {
          delete zone.supervision.timeoutSeconds;
        }
      }

      refreshZonesMeta();
    });

	    els.zoneTableBody.addEventListener("change", (evt) => {
	      const target = evt.target;
      if (!target) return;
      const tr = target.closest("tr");
      if (!tr) return;
      const index = Number(tr.dataset.index);
      if (!Number.isInteger(index) || index < 0 || index >= zonesModel.length) return;
      const zone = zonesModel[index];
      const field = target.dataset.field;

	      if (field === "kind") {
	        applyZoneKind(zone, target.value);
	        refreshZonesMeta();
	      }

      if (field === "supEnabled") {
        const enabled = target.checked === true;
        if (enabled) {
          if (!zone.supervision || typeof zone.supervision !== "object") {
            zone.supervision = { enabled: true, blockArm: true };
          }
          zone.supervision.enabled = true;
          if (!Object.prototype.hasOwnProperty.call(zone.supervision, "blockArm")) {
            zone.supervision.blockArm = true;
          }
          const timeoutEl = tr.querySelector('input[data-field="supTimeout"]');
          const blockEl = tr.querySelector('input[data-field="supBlockArm"]');
          if (timeoutEl) timeoutEl.disabled = false;
          if (blockEl) blockEl.disabled = false;
        } else {
          delete zone.supervision;
          const timeoutEl = tr.querySelector('input[data-field="supTimeout"]');
          const blockEl = tr.querySelector('input[data-field="supBlockArm"]');
          if (timeoutEl) {
            timeoutEl.disabled = true;
            timeoutEl.value = "";
          }
          if (blockEl) {
            blockEl.disabled = true;
            blockEl.checked = true;
          }
        }
        refreshZonesMeta();
      }

      if (field === "supBlockArm") {
        if (!zone.supervision || typeof zone.supervision !== "object") {
          zone.supervision = { enabled: true };
        }
        zone.supervision.enabled = true;
        zone.supervision.blockArm = target.checked === true;
        refreshZonesMeta();
      }
    });

    // Track editing state to avoid autosave while typing.
    els.zoneTableBody.addEventListener("focusin", () => {
      isEditingZoneTable = true;
      if (autoSaveTimer) window.clearTimeout(autoSaveTimer);
      autoSaveTimer = null;
      setAutosaveHint("Autosave paused while editing zones.");
    });

    els.zoneTableBody.addEventListener("focusout", () => {
      setTimeout(() => {
        const active = document.activeElement;
        const stillInside =
          active && els.zoneTableBody && els.zoneTableBody.contains(active);
        if (stillInside) return;
        isEditingZoneTable = false;
        refreshZonesMeta();
        // Flush as soon as the user leaves the zone table, to reduce lost changes.
        flushZonesToEditor(true);
      }, 0);
    });

    els.zoneTableBody.addEventListener("click", (evt) => {
      const target = evt.target;
      if (!target) return;
      if (target.dataset.action !== "delete") return;
      const tr = target.closest("tr");
      if (!tr) return;
      const index = Number(tr.dataset.index);
      if (!Number.isInteger(index) || index < 0 || index >= zonesModel.length) return;
      zonesModel.splice(index, 1);
      renderZones();
    });

    function renderZoneContext(nodeName) {
      const name = String(nodeName || "").trim() || page.alarmNodeName;
      if (page.alarmNodeId) {
        const label = name ? `${name}` : "(unnamed Alarm)";
        els.zoneContext.innerHTML = `Target Alarm: <span class="pill">${label}</span> • synced automatically (click Done in Node-RED editor to apply)`;
        return;
      }
      els.zoneContext.textContent =
        "Tip: open this page from the Alarm node editor to load/save zones automatically.";
    }
    renderZoneContext();

    if (canTalkToEditor()) {
      requestZonesFromEditor();
    }

    function handleEditorZonesMessage(data) {
      if (!data || data.type !== "alarm-ultimate-zones") return;
      if (page.alarmNodeId && data.nodeId !== page.alarmNodeId) return;
      if (typeof data.zonesJson !== "string") return;
      try {
        editorConnected = true;
        setConnectionState("connected");
        if (isEditingZoneTable) {
          // Avoid clobbering the user's focus/typing due to background sync.
          return;
        }
        setZonesFromJson(data.zonesJson);
        // Align lastAutosaved with the normalized JSON to avoid immediate re-save.
        lastAutoSavedJson = zonesJsonText;
        if (typeof data.nodeName === "string") {
          renderZoneContext(data.nodeName);
        }
        showStatus(els.genStatus, "ok", `Loaded ${zonesModel.length} zones from Alarm editor.`);
        setAutosaveHint(`Autosave: loaded ${zonesModel.length} zones.`);
      } catch (err) {
        showStatus(els.genStatus, "err", `Load failed: ${String(err && err.message ? err.message : err)}`);
        setAutosaveHint("Autosave: load failed.");
      }
    }

    window.addEventListener("message", (evt) => {
      if (evt.origin !== page.origin) return;
      const data = evt.data && typeof evt.data === "object" ? evt.data : null;
      handleEditorZonesMessage(data);
    });

    // Best-effort flush on close/navigation away, so edits are not lost if the user closes quickly.
    window.addEventListener("beforeunload", () => flushZonesToEditor(true));
    window.addEventListener("pagehide", () => flushZonesToEditor(true));
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) flushZonesToEditor(true);
    });

    if (bc) {
      bc.addEventListener("message", (evt) => {
        const data = evt && evt.data && typeof evt.data === "object" ? evt.data : null;
        handleEditorZonesMessage(data);
      });
    }

    // Initial render.
    renderZones();
    setConnectionState(canTalkToEditor() ? "connecting" : "disconnected");
  </script>
</body>

</html>
